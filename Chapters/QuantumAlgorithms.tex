\chapter{\tl{Quantum Algorithms}}

\section{\tl{Probabilistic Versus Quantum Algorithms}}
Οι πιθανοτικοί αλγόριθμοι έχουν ευρεία χρήση στη θεωρητική πληροφορική καθώς χρησιμοποιούνται στη λύση πολλών διαφορετικών προβλημάτων. Σε αυτό το κεφάλαιο θα δούμε πως είναι δυνατό οι κβαντικοί αλγόριθμοι να αποτελέσουν μια γενίκευση των πιθανοτικών αλγορίθμων.

Θα ξεκινήσουμε με ένα απλό παράδειγμα ενός πιθανοτικού αλγόριθμου. Το παρακάτω σχήμα απεικονίζει τα πρώτα δύο βήματα ενός τέτοιου υπολογισμού σε έναν καταχωρητή ο οποίος μπορεί να βρίσκεται σε μια από τις τέσσερις καταστάσεις.

\begin{tikzpicture}[
  ->,
  >=stealth',
  shorten >=1pt,
  auto,
  node distance=2.8cm,
  semithick,
  every state/.style={fill=black,draw=none,text=white},
]

\node[shape=circle,draw=black] at (0,0) (0) {0};
1
\node[shape=circle,draw=black] at (3,1.8) (a) {0};
\node[shape=circle,draw=black] at (3,0.8) (b) {1};
\node[shape=circle,draw=black] at (3,-0.8) (c) {2};
\node[shape=circle,draw=black] at (3,-1.8) (d) {3};


\node[shape=circle,draw=black] at (6,1.8) (a1) {0};
\node[shape=circle,draw=black] at (6,0.8) (b1) {1};
\node[shape=circle,draw=black] at (6,-0.8) (c1) {2};
\node[shape=circle,draw=black] at (6,-1.8) (d1) {3};

\path[every node/.style={sloped,anchor=south,auto=false}]
     (0) edge              node {$p_{0,0}$} (a)
     (0) edge              node {$p_{0,1}$} (b)
     (0) edge              node {$p_{0,2}$} (c)
     (0) edge              node {$p_{0,3}$} (d);

\path[every node/.style={sloped,anchor=south,auto=false}]
     (a) edge              node {$q_{0,0}$} (a1)
     (a) edge              node {$q_{0,1}$} (b1)
     (a) edge              node {} (c1)
     (a) edge              node {} (d1)

     (b) edge              node {} (a1)
     (b) edge              node {} (b1)
     (b) edge              node {} (c1)
     (b) edge              node {} (d1)

     (c) edge              node {} (a1)
     (c) edge              node {} (b1)
     (c) edge              node {} (c1)
     (c) edge              node {$q_{2,3}$} (d1)

     (d) edge              node {} (a1)
     (d) edge              node {} (b1)
     (d) edge              node {} (c1)
     (d) edge              node {$q_{3,3}$} (d1);

\end{tikzpicture}


Αρχικοποιούμε τον καταχωρητή στο $0$. Μετά το πρώτο βήμα, ο καταχωρητής είναι στην κατάσταση $j$ με πιθανότητα $p_{0,j}$. Υποθέτωντας ότι θέλουμε να βρούμε τη συνολική πιθανότητα ότι ο υπολογισμός τερματίζει στην κατάσταση $3$ μετά το δεύτερο βήμα. Αυτός ο υπολογισμός γίνεται σε δύο στάδια. Αρχικά υπολογίζουμε την πιθαντότητα που σχετίζεται με τα διαφορετικά υπολογιστικά μονοπάτια τα οποία τερματίζουν στην κατάσταση $3$ και στη συνέχεια προσθέτωντας τις πιθανότητες όλων αυτών των διαφορετικών μονοπατιών. Μπορούμε να μεταβούμε από την κατάσταση $0$ στην κατάσταση $j$ και στη συνέχεια από την κατάσταση $j$ στην κατάσταση $3$ με ένα από τα τέσσερα $j \epsilon {0, 1, 2, 3}$. Όπως είναι ήδη γνωστό η πιθανότητα που σχετίζεται με καθένα από τα μονοπάτια βρίσκεται εάν πολλαπλασιάσουμε την πιθανότητα $p_{0,j}$ της μετάβασης από την $0$ στην $j$ με την πιθανότητα $q_{j,3}$ της μετάβασης από τη $j$ στην $3$. Η συνολική πιθανότητα να τερματίσουμε στην $3$ δίνεται αν προσθέσουμε τις τέσσερις πιθανότητες που προκύπτουν.
Όμως οι πιθανότητες αυτές που προκύπτουν είναι τα τετράγωνα των κβαντικών πιθανοτικών πλατών. Δηλαδή $p_{0,j} = \vert \alpha_{0,j} \vert ^2$ και $q_{j,k} = \vert \beta_{j,k} \vert^2$.
Άρα το τελικό αποτέλεσμα που προκύπτει είναι~\cite{Kaye:2007:IQC:1206629}:

\begin{align*}
  prob = \sum_{j} p_{0,j}q_{j,3}
\end{align*}

Και εδώ έχουμε το προηγούμενο σχήμα με χρήση κβαντικών πλατών.

\begin{tikzpicture}[
  ->,
  >=stealth',
  shorten >=1pt,
  auto,
  node distance=2.8cm,
  semithick,
  every state/.style={fill=black,draw=none,text=white},
]

\node[shape=circle,draw=black] at (0,0) (0) {0};
1
\node[shape=circle,draw=black] at (3,2) (a) {0};
\node[shape=circle,draw=black] at (3,1) (b) {1};
\node[shape=circle,draw=black] at (3,-1) (c) {2};
\node[shape=circle,draw=black] at (3,-2) (d) {3};


\node[shape=circle,draw=black] at (6,2) (a1) {0};
\node[shape=circle,draw=black] at (6,1) (b1) {1};
\node[shape=circle,draw=black] at (6,-1) (c1) {2};
\node[shape=circle,draw=black] at (6,-2) (d1) {3};

\path[every node/.style={sloped,anchor=south,auto=false}]
     (0) edge              node {$\vert \alpha_{0,0} \vert^2$} (a)
     (0) edge              node {$\vert \alpha_{0,1} \vert^2$} (b)
     (0) edge              node {$\vert \alpha_{0,2} \vert^2$} (c)
     (0) edge              node {$\vert \alpha_{0,3} \vert^2$} (d);

\path[every node/.style={sloped,anchor=south,auto=false}]
     (a) edge              node {$\vert \beta{0,0} \vert^2$} (a1)
     (a) edge              node {} (b1)
     (a) edge              node {} (c1)
     (a) edge              node {} (d1)

     (b) edge              node {} (a1)
     (b) edge              node {} (b1)
     (b) edge              node {} (c1)
     (b) edge              node {} (d1)

     (c) edge              node {} (a1)
     (c) edge              node {} (b1)
     (c) edge              node {} (c1)
     (c) edge              node {} (d1)

     (d) edge              node {} (a1)
     (d) edge              node {} (b1)
     (d) edge              node {} (c1)
     (d) edge              node {} (d1);

\end{tikzpicture}

Αν μετρήσουμε την κατάσταση αμέσως μετά το πρώτο βήμα του υπολογισμού, η πιθανότητα να προκύψει το αποτέλεσμα 2 είναι:

\begin{align*}
  prob = \vert \alpha_{0,2} \vert ^2 = p_{0,2}
\end{align*}

Και τελικά η συνολική πιθανότητα να μετρήσουμε το αποτέλεσμα 3 μετά το δεύτερο βήμα είναι:

\begin{flalign*}
  prob_3 &= \sum_{j} \vert \alpha_{0,j} \vert^2 \vert \beta_{j,3} \vert^2&&\\
  &= \sum_{j} \vert \alpha_{0,j}\beta_{j,3} \vert^2 &&
\end{flalign*}

Παρότι στο συγκεκριμένο παράδειγμα κάναμε τις μετρήσεις αμέσως μετά από κάθε βήμα, σε ένα κβαντικό αλγόριθμο αυτό δεν είναι εφικτό. Αυτό σημαίνει ότι τα κβαντικά πλάτη θα μπορούσαν να επηρεάσουν το τελικό αποτέλεσμα. Δηλαδή αν μετρήσουμε τη συνολική πιθαντότητα να φτάσουμε στην τελική κατάσταση 3, μετά το δεύτερο βήμα, το αποτέλεσμα είναι διαφορετικό από ότι πριν γιατί δεν γνωρίζουμε τη διαδρομή που ακολούθησε ο αλγόριθμος μέχρι να φτάσει εκεί. Σε αυτή τη περίπτωση λοιπόν, αντί να προσθέσουμε τις πιθανότητες, προσθέτουμε τα πλάτη των πιθανοτήτων. Άρα η πιθανότητα να φτάσουμε στο αποτέλεσμα 3 μετά το δεύτερο βήμα προκύπτει από το τετράγωνο του συνολικού πλάτους της πιθαντότητας αυτής.

\begin{align*}
  prob_3 = \vert \sum_{j} \alpha_{0,j} \beta_{j,3} \vert ^2
\end{align*}
Και λίγο πιο παραστατικά:

\begin{tikzpicture}[
  ->,
  >=stealth',
  shorten >=1pt,
  auto,
  node distance=2.8cm,
  semithick,
  every state/.style={fill=black,draw=none,text=white},
]

\node[shape=circle,draw=black] at (0,0) (0) {$\vert 0 \rangle$};
1
\node[shape=circle,draw=black] at (3,2) (a) {$\vert 0 \rangle$};
\node[shape=circle,draw=black] at (3,1) (b) {$\vert 1 \rangle$};
\node[shape=circle,draw=black] at (3,-1) (c) {$\vert 2 \rangle$};
\node[shape=circle,draw=black] at (3,-2) (d) {$\vert 3 \rangle$};


\node[shape=circle,draw=black] at (6,2) (a1) {$\vert 0 \rangle$};
\node[shape=circle,draw=black] at (6,1) (b1) {$\vert 1 \rangle$};
\node[shape=circle,draw=black] at (6,-1) (c1) {$\vert 2 \rangle$};
\node[shape=circle,draw=black] at (6,-2) (d1) {$\vert 3 \rangle$};

\path[every node/.style={sloped,anchor=south,auto=false}]
     (0) edge              node {$\alpha_{0,0}$} (a)
     (0) edge              node {$\alpha_{0,1}$} (b)
     (0) edge              node {$\alpha_{0,2}$} (c)
     (0) edge              node {$\alpha_{0,3}$} (d);

\path[every node/.style={sloped,anchor=south,auto=false}]
     (a) edge              node {$\beta_{0,0}$} (a1)
     (a) edge              node {$\beta_{0,1}$} (b1)
     (a) edge              node {} (c1)
     (a) edge              node {} (d1)

     (b) edge              node {} (a1)
     (b) edge              node {} (b1)
     (b) edge              node {} (c1)
     (b) edge              node {} (d1)

     (c) edge              node {} (a1)
     (c) edge              node {} (b1)
     (c) edge              node {} (c1)
     (c) edge              node {$\beta_{2,3}$} (d1)

     (d) edge              node {} (a1)
     (d) edge              node {} (b1)
     (d) edge              node {} (c1)
     (d) edge              node {$\beta_{3,3}$} (d1);

\end{tikzpicture}

Όπως μπορούμε να δούμε, οι κλασσικοί πιθανοτικοί αλγόριθμοι μπορούν να προσομοιαστούν από τους κβανιτκούς αλγορίθμους. Είναι εφικτή όμως η αντίστροφη διαδικασία; Η αντικατάσταση μιας κβαντικής πύλης με μια πιθανοτική κλασσική πύλη μπορεί να δώσει τελείως διαφορετικά αποτελέσματα, άρα δεν είναι μια εφικτή λύση. Ωστόσο σε κάποιες συγκεκριμένες περιπτώσεις όπως τα κβαντικά κυκλώματα που χρησιμοποιούν μόνο πύλες $CNOT, H, X, Y, Z, T$, μπορούν να προσομοιαστούν σε έναν κλασσικό υπολογιστή. Μπορούμε να συμπεράνουμε ότι είναι πολύ πιθανό οι κβαντικοί αλγόριθμοι να επιλύουν πολύ πιο γρήγορα τα όποια προβλημάτα σε σχέση με τους κλασσικούς πιθανοτικούς αλγορίθμους.

\section{\tl{Quantum Parallelism}}

Ο κβαντικός παραλληλισμός ($parallelism$) αποτελεί βασικό στοιχείο για πολλούς αλγόριθμους. Πολύ γενικά θα μπορούσαμε να πούμε ότι επιτρέπει σε έναν κβαντικό υπολογιστή να "αξιολογήσει" μια συνάρτηση $f(x)$ για πολλές διαφορετικές τιμές του $x$ ταυτόχρονα.

Έστω ότι έχουμε μια συνάρτηση $f(x): {0,1} \rightarrow {0,1}$. Σε έναν κβαντικό υπλογιστή, μπορούμε να υπολογίσουμε τη συνάρτηση αυτή θεωρώντας έναν κβαντικό υπολογιστή με δύο $qubits$ που ξεκινάει με την κατάσταση $\vert x,y \rangle$. Με μια ακολουθία λογικών πυλών μπορούμε να το μετασχηματίσουμε στην κατάσταση $\vert x,y \oplus f(x \rangle)$. Ο πρώτος καταχωρητής ονομάζεται $data register$ και ο δέυτερος $target register$. Ονομάζομουν τον μετασχηματισμό $U_f = \vert x,y \rangle \rightarrow \vert x,y \oplus f(x) \rangle$.

Έστω ένα κύκλωμα που εφαρμόζει την $U_f$ σε μια είσοδο αλλά όχι σε υπολογιστική βάση. Τότε ο $data register$ είναι προετοιμασμένος για την υπέρθεση $(\vert 0 \rangle + \vert 1 \rangle)/\sqrt{2}$ το οποίο μπορούμε να το δημιουργήσουμε με μια πύλη $Hadamard$. Και εφαρμόζοντας την $U_f$ έχουμε~\cite{Nielsen:2011:QCQ:1972505}:

\begin{align*}
  \frac{\vert 0, f(0)\rangle + \vert 1, f(1)\rangle} {\sqrt{2}}.
\end{align*}

Και εδώ είναι το σημαντικότερο σημείο, γιατί οι διαφορετικοί όροι περιέχουν πληροφορίες τόσο για την $f(0)$ αλλά και για την $f(1)$ σχεδόν ταυτόχρονα. Αντίθετα με τον κλασσικό παραλληλισμό, όπου πολλαπλά κυκλώματα προσπαθούσαν να υπολογίσουν την $f(x)$ ταυτόχρονα, εδώ ένα και μόνο κύκλωμα	υπολογίζει πολλαπλές τιμές χρησιμοποιώντας τη δυνατότητα των κβαντικών υπλογιστών να είναι σε υπερθέσεις διαφορετικών καταστάσεων.

Η παραπάνω διαδικασία/παράδειγμα θα μπορούσε να γενικευτεί σε συναρτήσεις με έναν τυχαίο αριθμό $bits$ χρησιμοποιώντας τη γενική διαδικασία $Hadamard Transform$ ή $Walsh-Hadamard Transform$. Η συγκεκριμένη διαδικασία είναι επί της ουσίας $n$ πύλες $Hadamard$ που δρουν παράλληλα σε $n qubits$.

Παρότι ο κβαντικός παραλληλισμός μας δίνει τη δυνατότηα να ελέγξουμε όλες τις πιθανές τιμές της $f$ ταυτόχρονα, δεν μπορεί να χρησιμοποιηθεί απευθείας.
 Στο παράδειγμα μας η μέτρηση της κατάστασης θα επέστρεφε είτε $\vert 0, f(0\rangle)$ είτε $\vert 1, f(1)\rangle$ μόνο. Στη γενική περίπτωση η μέτρηση της κατάστασης $\sum_{x} \vert x, f(x) \rangle$ θα έδινε μόνο $f(x)$ για μια μοναδική τιμή $x$, κάτι που θα μπορούσε να κάνει και ένας κλασσικός υπολογιστής. Ένας κβαντικός υπολογισμός, απαιτεί περισσότερα από έναν κβαντικό παραλληλισμό καθώς χρειάζεται την δυνατότητα να αντλεί πληροφορίες για παραπάνω από μια τιμή της $f(x)$ από την υπέρθεση της κατάστασης $\sum_{x} \vert x, f(x) \rangle$.

\section{\tl{Deutsch's Algorithm}}

Ο κβαντικός αλγόριθμος του $Deutsch$ είναι ένας από τους πρώτους και πιο απλούς κβαντικούς αλγορίθους. Ο κβαντικός αλγόριθμος του $Deutsch$ συνδυάζει τον κβαντικό παραλληλισμό που είδαμε παραπάνω με κάποιες βασικά στοχεία της κβαντομηχανικής γνωστά ως $"interference"$. Αρχικά θα χρησιμοποιήσουμε πάλι μια πύλη $Hadamard$ για να ετοιμάσουμε το πρώτο $qubit$ της υπέρθεσης $\frac{\vert 0 \rangle + \vert 1 \rangle}{\sqrt{2}}$, αλλά τώρα ετοιμάζουμε και ένα δέυτερο $qubit, y$ σαν την υπέρθεση $\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}}$ χρησιμοποιώντας μια πυλη $Hadamard$ στην κατάσταση $\vert 1 \rangle$.
Παρακάτω η διάταξη του αλγορίθμου:\\
\\
\includegraphics[width=10cm]{figures/DeutschAlgo.png}\\
\\
Ας δούμε λίγο επιγραμματικά τον αλγόριθμο. Όπως είπαμε ξεκινάμε περίπου όπως στο παράδειγμα για τον κβαντικό παραλληλισμό. Αρχικά η κατάσταση του καταχωρητή	είναι $\vert 01 \rangle$. Στη συνέχεια δρουν οι δύο πύλες $Hadamard$. Μετά ξεκινάει ο συνδυασμός κβαντικών πυλών $U_f$ και ακολουθεί η πύλη στο πρώτο $qubit$. Μετράμε την κατάσταση του πρώτου $qubit$. Αν είναι στην κατάσταση $\vert 0 \rangle$, τότε η $f(x)$ είναι σταθερή ενώ αν βρεθεί στην κατάσταση $\vert 1 \rangle$ η $f(x)$ είναι ισορροπημένη~\cite{Bellac:2006:SIQ:1202004}.




\section{\tl{Deutsch-Jozsa Algorithm}}

\section{\tl{Simon's Algorithm}}

\section{\tl{Grover's Algorithm}}

\section{\tl{Quantum Search Algorithms}}
