\chapter{\tl{Quantum Algorithms}}

\section{\tl{Probabilistic Versus Quantum Algorithms}}
Οι πιθανοτικοί αλγόριθμοι έχουν ευρεία χρήση στη θεωρητική πληροφορική καθώς χρησιμοποιούνται στη λύση πολλών διαφορετικών προβλημάτων. Σε αυτό το κεφάλαιο θα δούμε πως είναι δυνατό οι κβαντικοί αλγόριθμοι να αποτελέσουν μια γενίκευση των πιθανοτικών αλγορίθμων.

Θα ξεκινήσουμε με ένα απλό παράδειγμα ενός κλασσικού πιθανοτικού αλγόριθμου. Το παρακάτω σχήμα απεικονίζει τα πρώτα δύο βήματα ενός τέτοιου υπολογισμού σε έναν καταχωρητή ο οποίος μπορεί να βρίσκεται σε μια από τις τέσσερις καταστάσεις.

\begin{tikzpicture}[
  ->,
  >=stealth',
  shorten >=1pt,
  auto,
  node distance=2.8cm,
  semithick,
  every state/.style={fill=black,draw=none,text=white},
]

\node[shape=circle,draw=black] at (0,0) (0) {0};
1
\node[shape=circle,draw=black] at (3,1.8) (a) {0};
\node[shape=circle,draw=black] at (3,0.8) (b) {1};
\node[shape=circle,draw=black] at (3,-0.8) (c) {2};
\node[shape=circle,draw=black] at (3,-1.8) (d) {3};


\node[shape=circle,draw=black] at (6,1.8) (a1) {0};
\node[shape=circle,draw=black] at (6,0.8) (b1) {1};
\node[shape=circle,draw=black] at (6,-0.8) (c1) {2};
\node[shape=circle,draw=black] at (6,-1.8) (d1) {3};

\path[every node/.style={sloped,anchor=south,auto=false}]
     (0) edge              node {$p_{0,0}$} (a)
     (0) edge              node {$p_{0,1}$} (b)
     (0) edge              node {$p_{0,2}$} (c)
     (0) edge              node {$p_{0,3}$} (d);

\path[every node/.style={sloped,anchor=south,auto=false}]
     (a) edge              node {$q_{0,0}$} (a1)
     (a) edge              node {$q_{0,1}$} (b1)
     (a) edge              node {} (c1)
     (a) edge              node {} (d1)

     (b) edge              node {} (a1)
     (b) edge              node {} (b1)
     (b) edge              node {} (c1)
     (b) edge              node {} (d1)

     (c) edge              node {} (a1)
     (c) edge              node {} (b1)
     (c) edge              node {} (c1)
     (c) edge              node {$q_{2,3}$} (d1)

     (d) edge              node {} (a1)
     (d) edge              node {} (b1)
     (d) edge              node {} (c1)
     (d) edge              node {$q_{3,3}$} (d1);

\end{tikzpicture}


Αρχικοποιούμε τον καταχωρητή στο $0$. Μετά το πρώτο βήμα, ο καταχωρητής είναι στην κατάσταση $j$ με πιθανότητα $p_{0,j}$. Υποθέτουμε ότι θέλουμε να βρούμε τη συνολική πιθανότητα ότι ο υπολογισμός τερματίζει στην κατάσταση $3$ μετά το δεύτερο βήμα. Αυτός ο υπολογισμός γίνεται σε δύο στάδια. Στο πρώτο υπολογίζουμε την πιθανότητα που σχετίζεται με τα διαφορετικά υπολογιστικά μονοπάτια τα οποία τερματίζουν στην κατάσταση $3$ και στο δεύτερο προσθέτωντας τις πιθανότητες όλων αυτών των διαφορετικών μονοπατιών. Μπορούμε να μεταβούμε από την κατάσταση $0$ στην κατάσταση $j$ και στη συνέχεια από την κατάσταση $j$ στην κατάσταση $3$ με ένα από τα τέσσερα $j \epsilon {0, 1, 2, 3}$. Όπως είναι ήδη γνωστό η πιθανότητα που σχετίζεται με καθένα από τα μονοπάτια βρίσκεται εάν πολλαπλασιάσουμε την πιθανότητα $p_{0,j}$ της μετάβασης από την $0$ στην $j$ με την πιθανότητα $q_{j,3}$ της μετάβασης από τη $j$ στην $3$. Η συνολική πιθανότητα να τερματίσουμε στην $3$ δίνεται αν προσθέσουμε τις τέσσερις πιθανότητες που προκύπτουν.
Όμως οι πιθανότητες αυτές που προκύπτουν είναι τα τετράγωνα των κβαντικών πιθανοτικών πλατών. Δηλαδή $p_{0,j} = \vert \alpha_{0,j} \vert ^2$ και $q_{j,k} = \vert \beta_{j,k} \vert^2$.
Άρα το τελικό αποτέλεσμα που προκύπτει είναι~\cite{Kaye:2007:IQC:1206629}:

\begin{align*}
  prob = \sum_{j} p_{0,j}q_{j,3}
\end{align*}

Και εδώ έχουμε το προηγούμενο σχήμα με χρήση κβαντικών πλατών.

\begin{tikzpicture}[
  ->,
  >=stealth',
  shorten >=1pt,
  auto,
  node distance=2.8cm,
  semithick,
  every state/.style={fill=black,draw=none,text=white},
]

\node[shape=circle,draw=black] at (0,0) (0) {0};
1
\node[shape=circle,draw=black] at (3,2) (a) {0};
\node[shape=circle,draw=black] at (3,1) (b) {1};
\node[shape=circle,draw=black] at (3,-1) (c) {2};
\node[shape=circle,draw=black] at (3,-2) (d) {3};


\node[shape=circle,draw=black] at (6,2) (a1) {0};
\node[shape=circle,draw=black] at (6,1) (b1) {1};
\node[shape=circle,draw=black] at (6,-1) (c1) {2};
\node[shape=circle,draw=black] at (6,-2) (d1) {3};

\path[every node/.style={sloped,anchor=south,auto=false}]
     (0) edge              node {$\vert \alpha_{0,0} \vert^2$} (a)
     (0) edge              node {$\vert \alpha_{0,1} \vert^2$} (b)
     (0) edge              node {$\vert \alpha_{0,2} \vert^2$} (c)
     (0) edge              node {$\vert \alpha_{0,3} \vert^2$} (d);

\path[every node/.style={sloped,anchor=south,auto=false}]
     (a) edge              node {$\vert \beta{0,0} \vert^2$} (a1)
     (a) edge              node {} (b1)
     (a) edge              node {} (c1)
     (a) edge              node {} (d1)

     (b) edge              node {} (a1)
     (b) edge              node {} (b1)
     (b) edge              node {} (c1)
     (b) edge              node {} (d1)

     (c) edge              node {} (a1)
     (c) edge              node {} (b1)
     (c) edge              node {} (c1)
     (c) edge              node {} (d1)

     (d) edge              node {} (a1)
     (d) edge              node {} (b1)
     (d) edge              node {} (c1)
     (d) edge              node {} (d1);

\end{tikzpicture}

Αν μετρήσουμε την κατάσταση αμέσως μετά το πρώτο βήμα του υπολογισμού, η πιθανότητα να προκύψει το αποτέλεσμα 2 είναι:

\begin{align*}
  prob = \vert \alpha_{0,2} \vert ^2 = p_{0,2}
\end{align*}

Και τελικά η συνολική πιθανότητα να μετρήσουμε το αποτέλεσμα 3 μετά το δεύτερο βήμα είναι:

\begin{flalign*}
  prob_3 &= \sum_{j} \vert \alpha_{0,j} \vert^2 \vert \beta_{j,3} \vert^2&&\\
  &= \sum_{j} \vert \alpha_{0,j}\beta_{j,3} \vert^2 &&
\end{flalign*}

Παρότι στο συγκεκριμένο παράδειγμα κάναμε τις μετρήσεις αμέσως μετά από κάθε βήμα, σε ένα κβαντικό αλγόριθμο αυτό δεν είναι εφικτό. Αυτό σημαίνει ότι τα κβαντικά πλάτη θα μπορούσαν να επηρεάσουν το τελικό αποτέλεσμα. Δηλαδή αν μετρήσουμε τη συνολική πιθαντότητα να φτάσουμε στην τελική κατάσταση 3, μετά το δεύτερο βήμα, το αποτέλεσμα είναι διαφορετικό από ότι πριν γιατί δεν γνωρίζουμε τη διαδρομή που ακολούθησε ο αλγόριθμος μέχρι να φτάσει εκεί. Σε αυτή τη περίπτωση λοιπόν, αντί να προσθέσουμε τις πιθανότητες, προσθέτουμε τα πλάτη των πιθανοτήτων. Άρα η πιθανότητα να φτάσουμε στο αποτέλεσμα 3 μετά το δεύτερο βήμα προκύπτει από το τετράγωνο του συνολικού πλάτους της πιθαντότητας αυτής.

\begin{align*}
  prob_3 = \vert \sum_{j} \alpha_{0,j} \beta_{j,3} \vert ^2
\end{align*}
Και λίγο πιο παραστατικά:

\begin{tikzpicture}[
  ->,
  >=stealth',
  shorten >=1pt,
  auto,
  node distance=2.8cm,
  semithick,
  every state/.style={fill=black,draw=none,text=white},
]

\node[shape=circle,draw=black] at (0,0) (0) {$\vert 0 \rangle$};
1
\node[shape=circle,draw=black] at (3,2) (a) {$\vert 0 \rangle$};
\node[shape=circle,draw=black] at (3,1) (b) {$\vert 1 \rangle$};
\node[shape=circle,draw=black] at (3,-1) (c) {$\vert 2 \rangle$};
\node[shape=circle,draw=black] at (3,-2) (d) {$\vert 3 \rangle$};


\node[shape=circle,draw=black] at (6,2) (a1) {$\vert 0 \rangle$};
\node[shape=circle,draw=black] at (6,1) (b1) {$\vert 1 \rangle$};
\node[shape=circle,draw=black] at (6,-1) (c1) {$\vert 2 \rangle$};
\node[shape=circle,draw=black] at (6,-2) (d1) {$\vert 3 \rangle$};

\path[every node/.style={sloped,anchor=south,auto=false}]
     (0) edge              node {$\alpha_{0,0}$} (a)
     (0) edge              node {$\alpha_{0,1}$} (b)
     (0) edge              node {$\alpha_{0,2}$} (c)
     (0) edge              node {$\alpha_{0,3}$} (d);

\path[every node/.style={sloped,anchor=south,auto=false}]
     (a) edge              node {$\beta_{0,0}$} (a1)
     (a) edge              node {$\beta_{0,1}$} (b1)
     (a) edge              node {} (c1)
     (a) edge              node {} (d1)

     (b) edge              node {} (a1)
     (b) edge              node {} (b1)
     (b) edge              node {} (c1)
     (b) edge              node {} (d1)

     (c) edge              node {} (a1)
     (c) edge              node {} (b1)
     (c) edge              node {} (c1)
     (c) edge              node {$\beta_{2,3}$} (d1)

     (d) edge              node {} (a1)
     (d) edge              node {} (b1)
     (d) edge              node {} (c1)
     (d) edge              node {$\beta_{3,3}$} (d1);

\end{tikzpicture}

Όπως μπορούμε να δούμε, οι κλασσικοί πιθανοτικοί αλγόριθμοι μπορούν να προσομοιαστούν από τους κβανιτκούς αλγορίθμους. Είναι εφικτή όμως η αντίστροφη διαδικασία; Η αντικατάσταση μιας κβαντικής πύλης με μια πιθανοτική κλασσική πύλη μπορεί να δώσει τελείως διαφορετικά αποτελέσματα, άρα δεν είναι μια εφικτή λύση. Ωστόσο σε κάποιες συγκεκριμένες περιπτώσεις όπως τα κβαντικά κυκλώματα που χρησιμοποιούν μόνο πύλες $CNOT, H, X, Y, Z, T$, μπορούν να προσομοιαστούν σε έναν κλασσικό υπολογιστή. Μπορούμε να συμπεράνουμε ότι είναι πολύ πιθανό οι κβαντικοί αλγόριθμοι να επιλύουν πολύ πιο γρήγορα τα όποια προβλημάτα σε σχέση με τους κλασσικούς πιθανοτικούς αλγορίθμους.

\section{\tl{Quantum Parallelism}}

Ο κβαντικός παραλληλισμός ($parallelism$) αποτελεί βασικό στοιχείο για πολλούς αλγόριθμους. Πολύ γενικά θα μπορούσαμε να πούμε ότι επιτρέπει σε έναν κβαντικό υπολογιστή να <<αξιολογήσει>> μια συνάρτηση $f(x)$ για πολλές διαφορετικές τιμές του $x$ ταυτόχρονα.

Έστω ότι έχουμε μια συνάρτηση $f(x): {0,1} \rightarrow {0,1}$. Μπορούμε να υπολογίσουμε τη συνάρτηση αυτή θεωρώντας έναν κβαντικό υπολογιστή με δύο $qubits$ που ξεκινάει με την κατάσταση $\vert x,y \rangle$. Με μια ακολουθία λογικών πυλών μπορούμε να το μετασχηματίσουμε στην κατάσταση $\vert x,y \oplus f(x \rangle)$. Ο πρώτος καταχωρητής ονομάζεται $data$ $register$ και ο δέυτερος $target$ $register$. Ονομάζομε τον μετασχηματισμό $U_f = \vert x,y \rangle \rightarrow \vert x,y \oplus f(x) \rangle$.

Έστω ένα κύκλωμα που εφαρμόζει την $U_f$ σε μια είσοδο αλλά όχι σε υπολογιστική βάση. Τότε ο $data$ $register$ είναι προετοιμασμένος για την υπέρθεση $(\vert 0 \rangle + \vert 1 \rangle)/\sqrt{2}$ το οποίο μπορούμε να το δημιουργήσουμε με μια πύλη $Hadamard$. Και εφαρμόζοντας την $U_f$ έχουμε~\cite{Nielsen:2011:QCQ:1972505}:

\begin{align*}
  \frac{\vert 0, f(0)\rangle + \vert 1, f(1)\rangle} {\sqrt{2}}.
\end{align*}

Και εδώ είναι το σημαντικότερο σημείο, γιατί οι διαφορετικοί όροι περιέχουν πληροφορίες τόσο για την $f(0)$ αλλά και για την $f(1)$ σχεδόν ταυτόχρονα. Αντίθετα με τον κλασσικό παραλληλισμό, όπου πολλαπλά κυκλώματα προσπαθούσαν να υπολογίσουν την $f(x)$ ταυτόχρονα, εδώ ένα και μόνο κύκλωμα	υπολογίζει πολλαπλές τιμές χρησιμοποιώντας τη δυνατότητα των κβαντικών υπλογιστών να είναι σε υπερθέσεις διαφορετικών καταστάσεων.

Η παραπάνω διαδικασία/παράδειγμα θα μπορούσε να γενικευτεί σε συναρτήσεις με έναν τυχαίο αριθμό $bits$ χρησιμοποιώντας τη γενική διαδικασία $Hadamard$ $Transform$ ή $Walsh-Hadamard$ $Transform$. Η συγκεκριμένη διαδικασία είναι επί της ουσίας $n$ πύλες $Hadamard$ που δρουν παράλληλα σε $n$ $qubits$.

Παρότι ο κβαντικός παραλληλισμός μας δίνει τη δυνατότητα να ελέγξουμε όλες τις πιθανές τιμές της $f$ ταυτόχρονα, δεν μπορεί να χρησιμοποιηθεί απευθείας.
Στο παράδειγμα μας η μέτρηση της κατάστασης θα επέστρεφε είτε $\vert 0, f(0\rangle)$ είτε $\vert 1, f(1)\rangle$ μόνο. Στη γενική περίπτωση η μέτρηση της κατάστασης $\sum_{x} \vert x, f(x) \rangle$ θα έδινε μόνο $f(x)$ για μια μοναδική τιμή $x$, κάτι που θα μπορούσε να κάνει και ένας κλασσικός υπολογιστής. Ένας κβαντικός υπολογισμός, απαιτεί περισσότερα από έναν κβαντικό παραλληλισμό καθώς χρειάζεται την δυνατότητα να αντλεί πληροφορίες για παραπάνω από μια τιμή της $f(x)$ από την υπέρθεση της κατάστασης $\sum_{x} \vert x, f(x) \rangle$.

\section{\tl{Deutsch's Algorithm}}

Ο κβαντικός αλγόριθμος του $Deutsch$ είναι ένας από τους πρώτους και πιο απλούς κβαντικούς αλγορίθους. Ο κβαντικός αλγόριθμος του $Deutsch$ συνδυάζει τον κβαντικό παραλληλισμό που είδαμε παραπάνω με κάποιες βασικά στοχεία της κβαντομηχανικής γνωστά ως $"interference"$. Αρχικά θα χρησιμοποιήσουμε πάλι μια πύλη $Hadamard$ για να ετοιμάσουμε το πρώτο $qubit$ της υπέρθεσης $\frac{\vert 0 \rangle + \vert 1 \rangle}{\sqrt{2}}$, αλλά τώρα ετοιμάζουμε και ένα δέυτερο $qubit,$ $y$ σαν την υπέρθεση $\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}}$ χρησιμοποιώντας μια πύλη $Hadamard$ στην κατάσταση $\vert 1 \rangle$.
Παρακάτω η διάταξη του αλγορίθμου:\\
\\
\includegraphics[width=10cm]{figures/DeutschAlgo.png}\\
\\
Ας δούμε λίγο επιγραμματικά τον αλγόριθμο. Ο στόχος του αλγορίθμου δεν είναι να υπολογίσουμε όλες τις ξεχωριστές τιμές της $f(x)$, αλλά να ορίσουμε την τιμή της $f(0) \oplus f(1)$. Όπως είπαμε ξεκινάμε περίπου όπως στο παράδειγμα για τον κβαντικό παραλληλισμό. Αρχικά η κατάσταση του καταχωρητή	είναι $\vert 01 \rangle$. Στη συνέχεια δρουν οι δύο πύλες $Hadamard$. Μετά ξεκινάει ο συνδυασμός κβαντικών πυλών $U_f$ και ακολουθεί η πύλη στο πρώτο $qubit$. Μετράμε την κατάσταση του πρώτου $qubit$. Αν είναι στην κατάσταση $\vert 0 \rangle$, τότε η $f(x)$ είναι σταθερή~\cite{Gudder2000-GUDUZA} ενώ αν βρεθεί στην κατάσταση $\vert 1 \rangle$ η $f(x)$ είναι ισορροπημένη~\cite{Bellac:2006:SIQ:1202004}.

Πιο αναλυτικά, αρχικά δημιουργούμε την κβαντική εκδοχή του κυκλώματατος για την $f$, και έτσι μπορούμε να δώσουμε κβαντικά $qubits$ σαν είσοδο. Επίσης έχουμε ορίσει την $U_f$ τέτοια ώστε αν θέσουμε το δεύτερο $qubit$ στην κατάσταση $\vert y \rangle = \vert 0 \rangle$, τότε το πρώτο $qubit$ που είναι στην κατάσταση $\vert x \rangle = \vert 0 \rangle$ θα δώσει $\vert 0 \oplus f(0) \rangle = \vert f(0) \rangle$ στο δεύτερο $qubit$ και αν έχουμε $\vert x \rangle = \vert 1 \rangle$ τότε το πρώτο $qubit$ θα μας δώσει
$\vert f(1) \rangle$. Βέβαια τα $qubits$ εισόδου δεν είναι απαραίτητο να είναι σε μια μόνο κατάσταση, αλλά μπορεί να βρίσκονται σε μια υπέρθεση των $\vert 0 \rangle$ και $\vert 1 \rangle$. Κρατώντας το δεύτερο $qubit$ στην κατάσταση $\vert y \rangle = \vert 0 \rangle$, θέτουμε το πρώτο $qubit$ σαν την υπέρθεση των δυο καταστάσεων, άρα:

 \begin{align*}
   \vert x \rangle = \frac{1}{\sqrt{2}}\vert 0 \rangle + \frac{1}{\sqrt{2}} \vert 1 \rangle
 \end{align*}

Επομένως η είσοδος που θα δώσουμε στην $U_f$ είναι:
\begin{align}
  (\frac{1}{\sqrt{2}}\vert 0 \rangle + \frac{1}{\sqrt{2}}\vert 1 \rangle)\vert 0 \rangle\\
  = \frac{1}{\sqrt{2}}\vert 0 \rangle \vert 0 \rangle + \frac{1}{\sqrt{2}}\vert 1 \rangle \vert 0 \rangle
\end{align}

Η έξοδος της $U_f$ είναι η εξής:

\begin{flalign}
   U_f (\frac{1}{\sqrt{2}}\vert 00 \rangle + \frac{1}{\sqrt{2}} \vert 10 \rangle) =&
  =\frac{1}{\sqrt{2}}U_f \vert 00 \rangle + \frac{1}{\sqrt{2}}U_f \rangle 10 \vert=&&\\
  &=\frac{1}{\sqrt{2}}\vert 0 \rangle \vert0 \oplus f(0) \rangle + \frac{1}{\sqrt{2}} \vert 1 \rangle \vert 0 \oplus f(1)\rangle = &&\\
  &= \frac{1}{\sqrt{2}} \vert 0 \rangle \vert f(0) \rangle + \frac{1}{\sqrt{2}} \vert 1 \rangle \vert 0 \oplus f(1) \rangle
\end{flalign}

Αν μετρούσαμε τώρα την έξοδο σε υπολογιστική βάση, το αποτέλεσμα θα ήταν είτε $\vert 0 \rangle \vert f(0) \rangle$ είτε $\vert 1 \rangle \vert 1 \oplus f(1) \rangle$. Μετά την μέτρηση, η κατάσταση της εξόδου θα είναι είτε $\vert f(0) \rangle$ είτε $\vert f(1) \rangle$. Όμως ο στόχος του αλγορίθμου δεν είναι να υπολογίσουμε όλες τις διαφορετικές τιμές της $f(x)$. Ο αλγόριθμος περιγράφει πως μπορούμε	 να χρησιμοποιήσουμε τους κβαντικούς μηχανισμούς ($interference$) για να βρουμε μια γενική πληροφορία για την $f$ και πως μπορούμε να το κάνουμε αυτό πολύ πιο αποδοτικά σε σχέση με τον κλασσικό τρόπο.
Αρχικά το πρώτο $bit$ είναι στην κατάσταση $\vert 0 \rangle$ και το δεύτερο στην κατάσταση $\frac{\vert 0 \rangle - \vert 1 \rangle}{2}$. Πριν επιδράσει καμία πύλη, έχουμε ότι
\begin{align}
  \vert \psi_0 \rangle = \vert 0 \rangle(\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}})
\end{align}

Αμέσως μετά την επίδραση της πρώτης πύλης $Hadamard$ στο πρώτο $qubit$ η κατάσταση γίνεται:

\begin{flalign}
  \vert \psi_1 \rangle &= (\frac{1}{\sqrt{2}} \vert 0 \rangle) =&&\\
  &= \frac{1}{\sqrt{2}} \vert 0 \rangle (\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}}) + \frac{1}{\sqrt{2}}\vert 1 \rangle (\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}})
\end{flalign}

Και στη συνέχεια επιδρά ο συνδυασμός πυλών $U_f$:

\begin{flalign}
  \vert \psi_2 \rangle &= \frac{(-1)^{f(0)}}{\sqrt{2}}\vert 0 \rangle (\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}}) + \frac{(-1)^{f(1)}}{\sqrt{2}} \vert 1 \rangle (\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}}) =&&\\
  &= (\frac{(-1)^{f(0)} \vert 0 \rangle + (-1)^{f(1)} \vert 1 \rangle}{\sqrt{2}})(\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}}) =&&\\
  &= (-1)^{f(0)} (\frac{\vert 0 \rangle + (-1)^{f(0) \oplus f(1)} \vert 1 \rangle}{\sqrt{2}})(\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}})
\end{flalign}

Εδώ έχουμε μερικές διαφορετικές περιπτώσεις. Αν η $f$ είναι σταθερή συνάρτηση, τότε έχουμε:

\begin{align}
  \vert \psi_2 \rangle = (-1)^{f(0)} (\frac{\vert 0 \rangle + \vert 1 \rangle}{\sqrt{2}})(\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}})
\end{align}

Και άρα η η τελευταία πύλη $Hadamard$ στο πρώτο $qubit$ μας δίνει το εξής:

\begin{align}
  \vert \psi_3 \rangle = (-1)^{f(0)} \vert 0 \rangle (\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}})
\end{align}

Αν όμως η $f$ είναι ισορροπημένη, τότε έχουμε:
\begin{align}
  \vert \psi_2 \rangle = (-1)^{f(0)}(\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}})(\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}})
\end{align}
και άρα η τελευταία πύλη μας δίνει:

\begin{align}
  \vert \psi_3 \rangle = (-1)^{f(0)} \vert 1 \rangle (\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}})
\end{align}

Προσπαθώντας να γενικοποιήσουμε λίγο τον αλγόριθμο του Deutsch, αρχικά θα πρέπει να θυμόμαστε ότι η $U_f: \vert x \rangle \vert y \rangle \rightarrow \vert x \rangle \vert y \oplus f(x) \rangle$, μπορεί να αντιμετωπιστεί ως ένας $single-qubit$ $operator \widehat(U_{f(x)})$ του οποίου η επίδραση στο δεύτερο $qubit$ εξαρτάται από την κατάσταση του πρώτου $qubit$.
Η κατάσταση $(\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}})$ είναι μια ιδιοκατάσταση $(eigenstate)$ της $\widehat(U_{f(x)})$ με ιδιοτιμή την $(-1)^{f(x)}$. Κωδικοποιώντας αυτές τις ιδιοτιμές με βάση το $qubit$ ελέγχου, δηλαδή το πρώτο $qubit$ μπορούμε να προσδιορίσουμε το $f(0) \oplus f(1)$, προσδιορίζοντας τους σχετικούς συντελεστές φάσης ανάμεσα στα $\vert 0 \rangle$ και $\vert 1 \rangle$. Η διάκριση μεταξύ των $(\frac{\vert 0 \rangle + \vert 1 \rangle}{\sqrt{2}})$ και $(\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}})$ γίνεται με την πύλη $Hadamard$~\cite{Kaye:2007:IQC:1206629}.

Κάτι άλλο που θα πρέπει να τονίσουμε είναι η δράση της πύλης $CNOT$. Όταν ο καταχωρητής αποτελείται από δυο $qubits$ οπως στην περίπτωση του αλγόριθμου του $Deutsch$, τότε η $CNOT$, δεν επηρεάζει την κατάσταση του πρώτου $qubit$, αλλα επιδρά στην κατάσταση του δεύτερου \textbf(εάν) το πρώτο βρίσκεται στην κατάσταση $\vert 1 \rangle$~\cite{Nakahara:2008}.

Συνοψίζοντας ο αλγόριθμος του $Deutsch$ μας δίνει λύση στο εξής:

\begin{tcolorbox}{\selectlanguage{english}The Deutsch Problem\\}
  \textbf{\selectlanguage{english}Input:} \selectlanguage{greek}Ένα μαύρο κουτί ($black box$) για τον υπολογισμό της άγνωστης συνάρτησης $f: {0,1} \rightarrow {0,1}$\\
  \textbf{\selectlanguage{english}Problem:} \selectlanguage{greek}Προσδιόρισε την τιμή της $f(0) \oplus f(1)$ κάνοντας ερωτήματα ($queries$) στην $f$
\end{tcolorbox}


% Επομένως στο πρώτο στάδιο του αλγορίθμου, ο κβανικτός καταχωρητής βρίσκεται στην κατάσταση ας την ονομάσουμε $q_1$.

% \begin{align*}
%   \vert q_1 \rangle = \vert 01 \rangle = \begin{bmatrix}
%     0 \\
%     1\\
%     0\\
%     0\\
% \end{bmatrix}
% \end{align*}
%
%
% Αμέσως μετά και πριν εφαρμοστεί η $U_f$, επιδρούν οι δύο κβαντικές πύλες $H$ και το τανυστικό γινόμενο καθώς και η νέα κατάσταση του καταχωρητή είναι:
%
% \begin{flalign*}
%   \vert q_2 \rangle = (H \oplus H) \vert q_1 \rangle &= (H \oplus H) \vert 01 \rangle =&&\\
%   &= \begin{bmatrix}
%     \frac{1}{2} &\frac{1}{2}  &\frac{1}{2}  &\frac{1}{2}\\
%     \frac{1}{2} &-\frac{1}{2} &\frac{1}{2}  &-\frac{1}{2}\\
%     \frac{1}{2} &\frac{1}{2}  &-\frac{1}{2} &-\frac{1}{2}\\
%     \frac{1}{2} &-\frac{1}{2} &-\frac{1}{2} &\frac{1}{2}\\
% \end{bmatrix}
% \begin{bmatrix}
%   0\\
%   1\\
%   0\\
%   0\\
% \end{bmatrix}=
% \begin{bmatrix}
%   \frac{1}{2}\\
%   -\frac{1}{2}\\
%   \frac{1}{2}\\
%   -\frac{1}{2}\\
% \end{bmatrix}=&&\\
% &= \frac{1}{2}\vert 00 \rangle - \frac{1}{2}\vert 10 \rangle + \frac{1}{2} \vert 10 \rangle - \frac{1}{2} \vert 11 \rangle=&&\\
% &=\frac{1}{2}(\vert 00 \rangle - \vert 01 \rangle + \vert 10 \rangle - \vert 11 \rangle)
% \end{flalign*}

\section{\tl{Deutsch-Jozsa Algorithm}}

Ο αλγόριθμος που θα δούμε τώρα αποτελεί τη λύση σε ένα πρόβλημα που είναι γενίκευση του προβλήματος που είδαμε στον αλγόριθμο του $Deutsch$. Ο αλγόριθμος έχει ακριβώς την ίδια δομή και δέχεται μια άγνωστη συνάρτηση $f$ που αυτή τη φορά είναι της μορφής:

\begin{align}
  f: {0,1}^n \rightarrow {0,1}
\end{align}

Επίσης η $f$, μπορεί να είναι είτε $constant$ (σταθερή για κάθε $x$) είτε $balanced$ (ισορροπημένη $f(x) = 0$ για τα μισά ακριβώς $x$, $f(x) = 1$ για τα υπόλοιπα $x$). Το ζητούμενο εδώ είναι να αποφασίσουμε αν τι είναι η $f$.

Ακολουθώντας την ίδια λογική που ακολουθήσαμε και στον προηγούμενο αλγόριθμο, θα ορίσουμε την κβαντική διαδικασία ως εξής:

\begin{align*}
  U_f: \vert x \rangle \vert y \rangle \rightarrow \vert x \rangle \vert y \otimes f(x) \rangle
\end{align*}

Το κύκλωμα φαίνεται παρακάτω:

\includegraphics[width=10cm]{figures/DeutschJosza}

Σε σχέση με τον αλγόριθμο του $Deutsch$, εδώ αντί για μια απλή $1-qubit$ πύλη $Hadamard$, έχουμε $n$ $1-qubit$ πύλες $Hadamard$ και συμβολίζεται ως $H^{\oplus n}$. Χρησιμοποιούμε το συμβολισμό $\vert 0 \rangle^{\otimes n}$ ή $\vert \textbf{0} \rangle$ για την κατάσταση που είναι $tensor$ $product$ από $n$ $qubits$ το καθένα στην κατάσταση $\vert 0 \rangle$.

Ακολουθούμε λοιπόν την πορεία του κυκλώματατος.
Αρχική κατάσταση

\begin{align}
  \vert \psi_0 \rangle = \vert 0 \rangle^{\oplus n}(\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}})
\end{align}

Υπολογίζοντας τη δράση ενός $n-qubit$ $Hadamard$ μετασχηματισμού στην κατάσταση $\vert 0 \rangle^{\oplus n}$

\begin{align}
  H^{\oplus n} \vert 0 \rangle^{\oplus 0} = (\frac{1}{\sqrt{2}})^n \underbrace{(\vert 0 \rangle + \vert 1 \rangle) \otimes (\vert 0 \rangle + \vert 1 \rangle) \otimes ... \otimes(\vert 0 \rangle + \vert 1 \rangle)}_{n}
\end{align}

Και εξάγοντας, το $tensor$ $product$ μπορεί να γραφτεί σαν

\begin{align}
  H^{\otimes n} \vert 0 \rangle^{\otimes n} = \frac{1}{\sqrt{2^n}} \sum_{x \epsilon {0,1}^n} \vert x \rangle
\end{align}

Αμέσως μετά την πρώτη $H^{\otimes n}$ ο αλγόριθμος είναι

\begin{align}
  \vert \psi_1 \rangle = \frac{1}{\sqrt{2^n}} \sum_{x \epsilon {0,1}^n} \vert n \rangle \frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}}
\end{align}

Η εγγραφή στον καταχωρητή είναι σε μια ισόβαρη υπέρθεση όλων των πιθανών $n-bit string$ εισόδου. Τώρα δρα η $U_f$

\begin{flalign}
  \vert \psi_2 \rangle &= \frac{1}{\sqrt{2^n}}U_f(\sum_{x \epsilon {0,1}^n}\vert x \rangle (\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}})) =&&\\
&= \frac{1}{\sqrt{2^n}} \sum_{x \epsilon {0,1}^n} (-1)^{f(x)} \vert x \rangle (\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}})
\end{flalign}

Η εγγραφή στον καταχωρητή είναι σε μια ισόβαρη υπέρθεση όλων των πιθανών $n-bit string$ εισόδου. Τώρα δρα η $U_f$

\begin{flalign}
  \vert \psi_2 \rangle &= \frac{1}{\sqrt{2^n}}U_f(\sum_{x \epsilon {0,1}^n}\vert x \rangle (\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}})) =&&\\
&= \frac{1}{\sqrt{2^n}} \sum_{x \epsilon {0,1}^n} (-1)^{f(x)} \vert x \rangle (\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}})
\end{flalign}

To $(-1)^{f(x)}$ είναι η μετατόπιση της φάσης, το οποίο έχει συνδεθεί με το πρώτο $qubit$.

Στη συνέχεια θα δούμε πως επιδρά η $n-οστή$ πύλη $Hadamard$ στο $n-qubit$ βασικής κατάστασης $\vert x \rangle$.

\begin{flalign}
  H^{\otimes n} \vert x \rangle &= H^{\otimes n}(\vert x_1 \rangle \vert x_2 \rangle ... \vert x_n \rangle)=&&\\
  &= H\vert x_1 \rangle H \vert x_2 \rangle...H \vert x_n \rangle=&&\\
  &= \frac{1}{\sqrt{2}}(\vert 0 \rangle + (-1)^{x_1} \vert 1 \rangle)\frac{1}{\sqrt{2}}(\vert 0 \rangle + (-1)^{x_2} \vert 1 \rangle)...\frac{1}{\sqrt{2}}(\vert 0 \rangle + (-1)^{x_n} \vert 1 \rangle)=&&\\
  &= \frac{1}{\sqrt{2}} \sum_{z_1z_2...z_n \epsilon {0,1}^n}(-1)^{x_1 z_1+...+x_n z_n}\vert z_1 \rangle \vert z_2 \rangle ... \vert z_n \rangle
\end{flalign}

Το τελικό αποτέλεσμα μετά την επίδραση της $n-οστής$ πύλης $Hadamard$:
\begin{flalign}
    \vert \psi_3 \rangle &= (\frac{1}{\sqrt{2^n}} \sum_{x \epsilon {0,1}^n} (-1)^{f(x)} \frac{1}{\sqrt{2^n}} \sum_{z \epsilon {0,1}^n} (-1)^{xz} \vert z \rangle)(\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}}) =&&\\
    &= \frac{1}{\sqrt{2^n}} \sum_{z \epsilon {0,1}^n} (\sum_{x \epsilon {0,1}^n} (-1)^{f(x)+xz})\vert z \rangle \frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}}
\end{flalign}

Και στις δύο παραπάνω εκφράσεις, το $x \centerdot z$ ορίζει το εσωτερικό γινόμενο των $x, z, modulo 2$.
Στο τέλος του αλγορίθμου, η μέτρηση του πρώτου καταχωρητή είναι σε υπολογιστική βάση και για να το δούμε καλυτερα, θεωρούμε το τελικό πλάτος του $\vert z \rangle =
\vert 0 \rangle^{\otimes n}$ στον πρώτο καταχωρητή κατάστασης $\vert \psi_3 \rangle$, το οποίο είναι:

\begin{align}
  \frac{1}{2^n} \sum_{x \epsilon {0,1}^n} (-1)^{f(x)}
\end{align}

Και τώρα έχουμε πάλι δύο περιπτώσεις.

\begin{enumerate}
  \item Η $f$ είναι $constant$, άρα το πλάτος του $\vert 0 \rangle^{\otimes n}$ είναι είτε +1 είτε -1 και επομένως η μέτρηση του πρώτου καταχωρητή είναι σίγουρο οτι θα μας επιστρέψει όλα τα 0.
  \item Η $f$ είναι $balanced$, άρα οι θετικές και αρνητικές συνιστώσες των πλατών αναιρούνται και το συνολικό πλάτος είναι $\vert 0 \rangle^{\otimes n} = 0$. Άρα η μέτρηση στον πρώτο καταχωρητή είναι βέβαιο ότι θα μας επιστρέψει όλες τις μη μηδενικές τιμές.
\end{enumerate}

Βλέπουμε επομένως ότι είναι πολύ εύκολο ανάλογα με τη μέτρηση του πρώτου καταχωρητή να κρίνουμε αν η $f$ είναι $balanced$ ή $constant$.

Ένας κλασσικός αλγόριθμος για να δώσει απάντηση στο πρόβλημα του $Deutsch-Josza$ χρειάζεται $2^{n-1} + 1$ $queries$ στην χειρότερη περίπτωση. Ένας πιθανοτικός κλασσικός αλγόριθμος θα μπορούσε να το λύσει με $\frac{1}{3}$ πιθανότητα λάθους χρησιμοποιώντας 2 μόνο $queries$. Η πιθανότητα λάθους μειώνεται στο $\frac{1}{2^n}$ με $n+1 queries$.
Βλέπουμε ότι η διαφορά μεταξύ της πολυπλοκότητας ενός κλασσικού πιθανοτικού $query$ και της πολυπλοκότητας ενός κβαντικού υπολογιστικού $query$, είναι σταθερή στην περίπτωση ενλος σταθερού $error$ και μετατρέπεται σε γραμμική διαφορά στην περίπτωση ενός μικρού εκθετικού $error$~\cite{Kaye:2007:IQC:1206629}.

Τελικά συνοψίζοντας τον αλγόριθμο~\cite{Nielsen:2011:QCQ:1972505}:
\begin{tcolorbox}
\selectlanguage{english}\textbf{Algorithm: Deutsch-Josza}\\
\textbf{Inputs:}\selectlanguage{greek}Ένα $black box U_f$ το οποίο εφαρμόζει τον εξής μετασχηματισμό $\vert x \rangle \vert y \rangle \rightarrow \vert x \rangle \vert y \oplus f(x) \rangle$ για κάθε $x \epsilon {0,...,2^n -1}$ και $f(X) \epsilon {0,1}$. Η $f(x)$ μπορεί να είναι είτε $constant$ είτε $balanced$ για όλες τις τιμές του $x$.\\
\selectlanguage{english} \textbf{Outputs:} \selectlanguage{greek} 0 ανν η $f$ είναι $constant$.\\
\selectlanguage{english} \textbf{Procedure:}
  \begin{enumerate}
    \item $\vert 0 \rangle^{\otimes n} \vert 1 \rangle$  initialize state
    \item $\rightarrow \frac{1}{\sqrt{2^n}} \sum_{x=0}^{2^n -1} \vert x \rangle [\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}}]$   create superposition using Hadamard gates
    \item $\rightarrow \sum_{x} (-1^f(x))\vert x \rangle [\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}}]$   calculate function f using $U_f$
    \item |$\rightarrow \sum_{z} \sum_{x} \frac{(-1)^{x z + f(x)}\vert z \rangle}{\sqrt{2^n}} [\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}}]$ perform Hadamard Transform
    \item $\rightarrow z$ measure to obtain final output z
  \end{enumerate}
\end{tcolorbox}

\section{\tl{Simon's Algorithm}}


Ο αλγόριθμος του $Simon$ είναι λίγο διαφορετικός από τους αλγορίθμους που είδαμε μέχρι τώρα και λύνει ένα άλλο πρόβλημα. Η γενική ιδέα είναι η εξής:

\begin{tcolorbox}
  \selectlanguage{english} \textbf{Simon's Problem}\\
  \textbf{Input:}\selectlanguage{greek} Ένα $black box$ για τον υπολογισμό της άγνωστης συνάρτησης $f: {0,1}^n \rightarrow X$, όπου το $X$ είναι ένα πεπερασμένο σύνολο.\\
  \selectlanguage{english}\textbf{Promise:} \selectlanguage{greek} Υπάρχει $string s = s_1s_2...s_n$ τέτοιο ώστε $f(x) = f(y)$ ανν $x = y$ ή $x = y \oplus s$.\\
  \selectlanguage{english}\textbf{Problem:} \selectlanguage{greek} Βρίσκουμε το $string s$ κάνοντας ερωτήματα στην $f$
\end{tcolorbox}

% \begin{theo}
%   Κάθε κλασσικός αλγόριθμο που λύνει αυτό το πρόβλημα με πιθανότητα το λιγότερο $\frac{2}{3}$ για κάθε τέτοια $f$, πρέπει να
% \end{theo}\

Στον προηγούμενο αλγόριθμο, είδαμε σε έναν $n-qubit$ $Hadamard$ μετασχηματισμό ισχύει το εξής:
\begin{align}
  H^{\otimes n} \vert 0 \rangle = \frac{1}{\sqrt{2^n}} \sum_{z \epsilon {0,1}^n} (-1)^{x z} \vert z \rangle
\end{align}

Αν όμως εφαρμόσουμε το $H^{\oplus n}$ σε μια υπέρθεση με δύο βασικές καταστάσεις όπως $\vert 0 \rangle + \vert s \rangle$ έχουμε
\begin{flalign}
  H^{\oplus n} \vert x \rangle (\frac{1}{\sqrt{2}}\vert 0 \rangle + \frac{1}{\sqrt{2}} \vert s \rangle) &= \frac{1}{\sqrt{2^{n+1}}} \sum_{z \epsilon {0,1}^n} \vert z \rangle + \frac{1}{\sqrt{2^{n+1}}} \sum_{z \epsilon {0,1}^n} (-1)^{s z} \vert z \rangle =&&\\
  &= \frac{1}{\sqrt{2^{n+1}}} \sum_{z \epsilon {0,1}^n} (1 + (-1)^{s z}) \vert z \rangle
\end{flalign}

Άρα:
\begin{align}
  H^{\oplus n}(\frac{1}{\sqrt{2}}\vert x \rangle + \frac{1}{\sqrt{2}} \vert y \rangle) = \frac{1}{\sqrt{2^{n-1}}} \sum_{z \epsilon {s}\bot} \vert z \rangle
\end{align}

\includegraphics[width=11cm]{figures/Simons}\\
Το κύκλωμα του αλγορίθμου.

Τα βήματα του αλγορίθμου περιληπτικά και θεωρώντας ότι έχουμε το αντιστρέψιμο $black$ $box$ για την υλοποίηση της $f$
\begin{align*}
  U_f: \vert x \rangle \vert b \rangle \rightarrow \vert x \rangle \vert b \otimes f(x) \rangle
\end{align*}

\begin{tcolorbox}
  \selectlanguage{english}\textbf{Algorithm for Simon's Problem}
  \begin{enumerate}
    \item Set a counter i = 1
    \item Prepare $\frac{1}{\sqrt{2^n}} \sum_{x \epsilon {0,1}^n} \vert x \rangle \vert 0 \rangle$
    \item Apply $U_f$, to produce the state $\sum_{x \epsilon {0,1}^n} \vert x \rangle \vert f(x) \rangle$
    \item Measure the second register
    \item Apply $H^{\otimes n}$ to the first register
    \item Measure the first register and record the value $w_i$
    \item If the dimension of the span of ${w_i}$ equals n-1, then go to Step 8, otherwise increment i and got to Step 2
    \item Solve the linear equation $W_s^T = 0^T$ and let s to be the unique non-zero solution
    \item Output s
  \end{enumerate}
\end{tcolorbox}

Επίσης ο αναμενόμενος αριθμός δειγμάτων από το $s \bot$ μέχρι να ολοκληρωθεί ο αλγόριθμος, είναι λιγότερα από $m + 1 = n$.
Και οδηγούμαστε στο παρακάτω θεώρημα:
\selectlanguage{greek}
\begin{theo}
  Ο αλγόριθμος μας οδηγεί στην εύρεση των κρυμμένων $strings$ στο πρόβλημα του $Simon$. Ο αναμενόμενος αριθμός των εκτιμήσεων της $f$ μέχρι να ολοκληρωθεί ο αλγόριθμος είναι λιγότερο από $n$ και ο αναμενόμενος αριθμός από άλλες στοιχειώδεις πύλες είναι στο $O(n^3)$
\end{theo}

Εάν θέλουμε να γενικεύσουμε το πρόβλημα του $Simon$ μπορούμε να το δούμε έτσι:
\begin{tcolorbox}
\selectlanguage{english}\textbf{Generalized Simon's Problem}\\
\textbf{Input:}\selectlanguage{greek}Ένα $black box U_f$ που υλοποιεί την $f: {0,1}^n \rightarrow X$, όπου το $X$ είναι κάποιο πεπερασμένο σύνολο.\\
\selectlanguage{english}\textbf{Promise:}$f(x) = f(y)$ \selectlanguage{greek} ανν $x - y \epsilon S$ για κάποιο υποσύνολο $S \leq Z_2^n$\\
\selectlanguage{english}\textbf{Problem:}\selectlanguage{greek} Η εύρεση μιας βάσης $s_1,...,s_m$ για κάποιο $S$, όπου $m$ η διάσταση του υποσυνόλου $S$
\end{tcolorbox}

Ο αλγόριθμος που επιλύει το γενικευμένο πρόβλημα του $Simon$ είναι περίπου ο ίδιος με το απλό πρόβλημα. Σημαντικό εδώ είναι ότι αν $S = {0, x_1,...,x_{2^{m-1}}}$ είναι ένα υποσύνολο διάστασης $m$ του $Z_2^n = {0,1}^n$ πάνω στο $Z_2$, τότε το σύνολο ${0,1}^n$ μπορεί να χωριστεί σε δύο $2^{n-m}$ υποσύνολα της μορφής ${y, y \oplus x_1, y \oplus x_2,..., y \oplus x_{2^{m-1}}}$, το οποίο αναφέρεται και ως $y + S$. Τότε στο 3ο βήμα μπορούμε να δούμε ότι έχουμε την κατάσταση
\begin{align}
  \sum_{x \epsilon {0,1}^n} \vert x \rangle \vert f(x) \rangle = \frac{1}{\sqrt{2^{n-m}}} \sum_{y \epsilon I} \vert y + S \rangle \vert f(y) \rangle
\end{align}
όπου το $I$ είναι το υποσύνολο του ${0,1}^n$ το οποίο αντιπροσωπεύεται από κάθε ένα από τα $2^{n-m}$ υποσύνολα.
Έτσι αφού μετρήσουμε τον δεύτερο καταχωρητή στο βήμα 4, ο πρώτος καταχωρητής είναι σε μια κατάσταση της μορφής $\vert y + S \rangle$ για ένα τυχαίο $y$. Στη συνέχεια μετά τον μετασχηματισμό $Hadamard$ στο βήμα 5, ο πρώτος καταχωρητής περιέχει μια ομοειδή υπέρθεση από στοιχεία του $S^\bot$, που σημαίνει ότι στο 6ο βήμα η μέτρηση στον πρώτο καταχωρητή μας επιστρέφει μια τιμή $w_i$ σε ομοιόμορφη δειγματοληψία από ένα τυχαίο $S^\bot$. Το μόνο τμήμα που αλλάζει είναι τα τελευταία τρία στάδια του αλγορίθμου.
Αν γνωρίζουμε τη διάσταση $m$ του $S$, τότε ξέρουμε ότι το $S^\bot$ έχει διαστάσεις $n - m$ και μπορούμε να αντικαταστήσουμε τα τελευταία 3 βήματα του αλγορίθμου με τα εξής:
\selectlanguage{english}
\begin{enumerate}
  \setcounter{enumi}{7}
  \item If the dimension of the span of ${w_i}$ equals n - m, then go to Step 8, otherwise increment $i$ and go to Step 2.
  \item Solve the linear equation $W_S^T = 0^T$ and let $s_1, s_2,..., s_m$ be generators of the solution space.
  \item Output $s_1, s_2,..., s_m$
\end{enumerate}
\selectlanguage{greek}
Και έχουμε το εξής θεώρημα:
\begin{theo}
  Ο <<νέος>> αλγόριθμος λύνει το πρόβλημα του $Simon$ με γνωστή τη διάσταση $m$ του $S$. Ο αναμενόμενος αριθμός αξιολογήσεων της $f$ στην εκτέλεση του αλγορίθμου είναι μικρότερη από $n - m + 1$ και $O(n^3)$ στοιχειώδεις διαδικασίες.
\end{theo}

Όταν δεν γνωρίζουμε το $m$, γνωρίζουμε ότι επαρκούν $m + 4$ δείγματα για τη δημιουργία του $S^\bot$ με πιθανότητα το λιγότερο $\frac{2}{3}$~\cite{Kaye:2007:IQC:1206629}.

\section{\tl{Grover's Algorithm - Quantum Search Algorithms}}
Ο επόμενος αλγόριθμος που θα δούμε είναι πιο περίπλοκος και λύνει ένα καινούριο πρόβλημα. Είναι ο πρώτος κβαντικός αλγόριθμος αναζήτησης.
Έστω ότι μας δίνεται ένα χάρτης με διάφορες πόλεις και θέλουμε να βρούμε τη συντομότερη διαδρομή που να περνάει από όλες τις πόλεις. Ένας απλός αλγόριθμος για αυτό, είναι να βρούμε όλες τις πιθανές διαδρομές και να κρατήσουμε τα μήκη τους ώστε να επιστρέψουμε τη συντομότερη διαδρομή. Σε έναν κλασσικό	υπολογιστή εάν υπάρχουν $N$ πιθανές διαδρομές, τότε θα μας πάρει $O(N)$ χρόνο για να βρούμε τη συντομότερη. Υπάρχει ωστόσο ένας κβαντικός αλγόριθμος αναζήτησης που μπορεί να επισπέυσει τη διαδικασία αυτή και να βρει τη συντομότερη διαδρομή σε $O(\sqrt{N})$ χρόνο. Αυτός ο αλγόριθμος είναι ο αλγόριθμος του $Grover$ και μπορεί να χρησιμοποιηθεί σε πολλά κλασσικά προβλήματα αναζήτησης~\cite{Nielsen:2011:QCQ:1972505}.
Ο $Lov$ $Grover$~\cite{Grover97quantummechanics} απέδειξε το 1966 ότι με έναν κβαντικό υπολογιστή μπορούμε να βρούμε ένα στοιχείο μέσα σε μια μη δομημένη βάση δεδομένων σε $\sqrt{N}$ φορές. Όσο αυξάνει το μέγεθος της βάσης, τόσο περισσότερο αυξάνεται και η ταχύτητα.
Επιπλέον ο ίδιος αλγόριθμος μπορεί να χρησιμοποιηθεί και για την εύρεση $k$ αντικειμένων τα οποία να ικανοποιούν μια συγκεκριμένη συνθήκη μέσα στο σύνολο $N$ με $\frac{\pi}{4}(\sqrt{\frac{N}{k}})$ δοκιμές~\cite{Nakahara:2008}~\cite{RilPerry}.
Ακόμα ο αλγόριθμος του $Grover$ μπορεί να έχει πολύ περισσότερες εφαρμογές στο πεδίο των μαθηματικών από ότι έχουμε σκεφτεί μέχρι σήμερα~\cite{Calude:2001:CCA:374924} και οι $Nielsen$ $Chuang$ υποστηρίζουν ότι μπορεί να βοηθήσει στην πιο γρήγορη επίλυση ορισμένων $NP-complete$ προβλημάτων~\cite{Nielsen:2011:QCQ:1972505}.

Ας υποθέσουμε ότι θέλουμε να ψάξουμε σε μια μη δομημένη βάση $N$ στοιχείων, όπου κάθε στοιχείο έχει αριθμηθεί από το 0 έως το $N-1$. Επιπλέον έχουμε ένα υποθετικό σύστημα το οποίο μπορεί να αναγνωρίσει εάν κάποιο στοιχείο είναι αυτό που θέλουμε ή όχι. Το σύστημα αυτό σε έναν κλασσικό υπολογιστή θα μπορούσε να είναι ένας καταχωρητής που έχουμε αποθηκεύσει το στοιχείο που ψάχνουμε και ένα κύκλωμα λογικών πυλών. Το κύκλωμα αυτό συγκρίνει κάθε νέο στοιχείο που έρχεται σαν είσοδος με το αποθηκευμένο στοιχείο. Το σύστημα αυτό το οποίο θεωρούμε ως ένα μάυρο κουτί, το ονομάζουμε $oracle$ στη διεθνή βιβλιογραφία.

Πως όμως λύνεται το πρόβλημα μας σε έναν κλασσικό υπολογιστή. Έστω ότι έχουμε τη βάση που αναφέραμε προηγουμένως. Το στοιχείο που αντιστοιχεί στον αριθμό $k$, το συμβολίζουμε με $x_k$. Το $oracle$ είναι μια συνάρτηση $f$ που παίρνει τιμές 0 και 1.
Για το στοιχείο $x_i$ που ψάχνουμε λοιπόν έχουμε\\
$f(x)=\left\{\begin{array}{rr}
   1, &x = x \\
   0, & x \neq x_i
   \end{array}
   \right.$
Δηλαδή δίνουμε ένα στοιχείο στην $oracle$ και μας επιστρέφεται 0 ή 1 ανάλογα με το αν είναι αυτό που ψάχνουμε ή όχι.

Ας δούμε τώρα την ίδια αναζήτηση σε έναν κβαντικό υπολογιστή. Μπορούμε να γράψουμε το πλήθος των στοιχείων και με τον εξής τρόπο:

\begin{align}
  N = 2^n, n = 1, 2, 3,...
\end{align}
και εφόσον έχουμε λιγότερα στοιχεία, μπροούμε να προσθέσουμε μέχρι να φτάσουμε στον επιθυμητό αριθμό.

Και στη συνέχεια αντιστοιχίζουμε κάθε ένα από τα στοιχεία αυτά σε μία από τις βασικές καταστάσεις ενός κβαντικού καταχωρητή με $n qubits$. Έστω το στοιχείο με δεκαδική αναπαράσταση $\vert 2 \rangle$ και συμβολίζεται με $\vert x_2 \rangle$ αντιστοιχεί στη βασική κατάσταση $\vert 000...00010 \rangle$~\cite{Nielsen:2011:QCQ:1972505}.

 \subsection{\tl{Oracle}}
Έστω ότι το κβαντικό $oracle$ βρίσκεται στην κατάσταση $\vert xy \rangle$, τότε:
\begin{align}
  \vert xy \rangle = \vert x \rangle \vert y \rangle \xrightarrow{\text{o}} \vert x \rangle \vert f(x) \oplus y \rangle
\end{align}
To $\vert y \rangle$ ονομάζεται $oracle$ $qubit$.
Αρχικά το $oracle$ $qubit$ είναι στην βασική κατάσταση $\vert 1 \rangle$ και αμέσως μετά επιδράσ ε αυτό μια κβαντική πύλη $H$. Και έχουμε:
\begin{align}
  \vert 1 \rangle \xrightarrow{\text{H}} \frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}}
\end{align}

Σε ένα τυχαίο στοιχείο $x$ θα ισχύει:
\begin{align}
  \vert x \rangle (\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}}) \xrightarrow{\text{o}} \vert x \rangle \vert f(x) \oplus \frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}}
\end{align}

Εάν η κατάσταση $\vert x \rangle$ δεν αντιστοιχεί στο στοιχείο που ψάχνουμε, τότε η $f(x)$ παίρνει την τιμή 0 και η σχέση (4.40) γίνεται:
\begin{flalign}
  \vert x \rangle (\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}}) \xrightarrow{\text{o}} \vert x \rangle (\vert 0 \rangle \oplus \frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}}) &= \vert x \rangle (\frac{\vert 0 \rangle \oplus \vert 0 \rangle - \vert 0 \rangle \oplus \vert 1 \rangle}{\sqrt{2}}) =&&\\
  &= \vert x \rangle (\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}})
\end{flalign}

Έστω τώρα ότι η $\vert x \rangle$ αντιστοιχεί στο στοιχείο που ψάχνουμε, η $f(x)$ παίρνει την τιμή 1 και έχουμε:
\begin{flalign}
  \vert x \rangle (\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}}) \xrightarrow{\text{o}} \vert x \rangle (\vert 1 \rangle \oplus \frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}}) &= \vert x \rangle (\frac{\vert 1 \rangle \oplus \vert 0 \rangle - \vert 1 \rangle \oplus \vert 1 \rangle}{\sqrt{2}}) =&&\\
  &= - \vert x \rangle (\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}})
\end{flalign}

Δεδομένου ότι το $qubit$ του κβανικού $oracle$ δεν μεταβάλλεται σε καμία περίπτωση μπορούμε να το απαλείψουμε από τις δύο παραπάνω σχέσεις και άρα έχουμε:\\
$\vert x \rangle \xrightarrow{\text{o}}\left\{\begin{array}{rr}
   + \vert x \rangle, &\vert x \rangle not the selected element \\
   - \vert x \rangle, &\vert x \rangle the selected element
   \end{array}
   \right.$

Και πιο συνοπτικά μπορούμε να γράψουμε την παραπάνω σχέση ως εξής:
\begin{align*}
  \vert x \rangle \xrightarrow{\text{o}} (-1)^{f(x)} \vert x \rangle
\end{align*}
όπου η $f(x)$ παίρνει τιμές 0 ή 1, άρα
$\vert x \rangle \xrightarrow{\text{o}}\left\{\begin{array}{rr}
   (-1)^0 \vert x \rangle = + \vert x \rangle, &f(x) = 0 \\
   (-1)^1 \vert x \rangle = - \vert x \rangle, &f(x) = 1
   \end{array}
   \right.$

Συνοψίζοντας λοιπόν όλα τα παραπάνω βλέπουμε ότι το κβαντικό $oracle$ δρα στις βασικές καταστάσεις $\vert x \rangle$. Αν η βασική κατάσταση αντιστοιχεί στο στοιχείο που ψάχνουμε τότε της αλλάζει το πρόσημο, αλλιώς την αφήνει όπως είναι.

\subsection{\tl{Algorithm's Procedure}}
Ο αλγόριθμος ξεκινάει με τον υπολογιστή να βρίσκεται στην κατάσταση $\vert 0 \rangle^{\otimes n}$ και στη συνέχεια εφαρμόζεται ο μετασχηματισμός $Hadamard$ για να θέσει τον υπολογιστή σε μια υπέρθεση της μορφής:
\begin{align}
  \vert s \rangle = \frac{1}{\sqrt{N}} \sum_{x=0}^{N-1} \vert x_i \rangle
\end{align}
Στη συνέχεια εφαρμόζονται επαναλαμβανόμενες υπορουτίνες που είνα γνωστές ως $Grover$ $iteration$ ή $Grover$ $operator$ και συμβολίζεται με $G$. Θα μπορούσαμε να αναλύσουμε την υπορουτίνα αυτή σε τέσσερα απλά προβλήματα
\begin{enumerate}
  \item Εφαρμόζουμε το $oracle$ $O$
  \item Εφαρμόζουμε τον μετασχηματισμό $Hadamard$ της μορφής $H^{\oplus n}$
  \item Κάνουμε μια μετατόπιση ($shift$) της φάσης όπου κάθε κατάσταση εκτός της $\vert 0 \rangle$ μετατοπίζεται κατά -1 $\vert x \rangle \rightarrow -(-1)^{\delta_{x0}} \vert x \rangle$
  \item Εφαρμογή του μετασχηματισμού $Hadamard$~\cite{Nielsen:2011:QCQ:1972505}
\end{enumerate}

Ας πάμε πάλι στην αρχική κατάσταση. Μια μέτρηση του καταχωρητή θα μας έδινε ακριβώς τα ίδια αποτελέσματα με την κλασσική περίπτωση. Δηλαδή θα είχαμε το επιθυμητό $\vert x_i \rangle$ με πιθανότητα $\frac{1}{\sqrt{2}}$. Ο στόχος μας είναι να σχηματίσουμε την κατάσταση $\vert s \rangle$ με κατάλληλο τρόπο, ώστε να αυξήσουμε την πιθανότητα αυτή. Αυτό γίνεται με το να αυξηθεί ο συντελεστής του $\vert x_i \rangle$ όσο το δυνατόν πιο κοντά στη μονάδα και ταυτόχρονα να μειωθούν οι συντελεστές των υπολοίπων καταστάσεων.
Όπως είπαμε η $\vert s \rangle$ είναι η υπέρθεση των $N$ βασικών καταστάσεων με $N = 2^n$
και ψάχνουμε για το στοιχείο που αντιστοιχεί στην $\vert x_i \rangle$. Θα θέσουμε $b=1$ όπου $b$ είναι ο αριθμός επαναλήψεων των επόμενων βημάτων.
\begin{enumerate}
  \item Εφαρμογή του τελεστή $\hat{O} = \hat{I} - 2\vert x_i \rangle \rangle x_i \vert$ στον κβαντικό καταχωρητή
  \item Εφαρμογή του τελεστή $\hat{G} = 2 \vert s \rangle \rangle s \vert - \hat{I}$ στον κβαντικό καταχωρητή.
\end{enumerate}
Αν ο αριθμός $b$ είναι μεγαλύτερος ή περίπου ίσος με $((\frac{\pi}{4})\sqrt{N}) - 0.5$ τότε μετράμε την κατάσταση του καταχωρητή και είναι σχεδόν βέβαιο ότι θα είναι η ζητούμενη. Αν όχι τότε ξαναγυρνάμε στο 1ο βήμα.

Στα παραπάνω βήματα, χρησιμοποιήσαμε το $\hat{I}$. Οι κβαντικές πύλες, επί της ουσίας είναι τελεστές του χώρου $Hilbert$ που δρουν σε $qubits$ και σε κβαντικούς καταχωρητές αλλάζοντας την κατάσταση τους. Από τη στιγμή λοιπόν που κάθε κβαντικό κύκλωμα είναι τελεστής του χώρου $Hilbert$, αυτόματα συμπεραίνουμε ότι και το $oracle$ είναι τελεστής του χώρου $Hilbert$.
Για το στοιχείο που ψάχνουμε, το $oracle$ είναι
\begin{align*}
  \hat{O} = \hat{I} - 2\vert x_i \rangle \rangle x_i \vert
\end{align*}
όπου $\hat{I}$ είναι ο τελεστής που αντιστοιχεί στην πύλη αδράνειας και όταν δρα δεν αλλάζει καμία κατάσταση.
Η μαθηματική αναπαράσταση του αλγορίθμου, θα μπορούσε να είναι η εξής:
\begin{tcolorbox}
  \selectlanguage{english}
  \textbf{Algorithm: Quantum Search}\\
  \textbf{Inputs:} (1) A black box oracle $O$ which performs the transformation $O\vert x \rangle \vert q \rangle = \vert x \rangle \vert q \oplus f(x) \rangle$ where $f(x) = 0$ for all $0 \leq x \leq 2^n$ except $x_0$ for which $f(x_0) = 1$\\
  (2) $n + 1$ qubits in the state $\vert 0 \rangle$\\
  \textbf{Outputs:} $x_0$\\
  \textbf{Runtime:} $O(\sqrt{2^n})$ operations. Succeeds with probability $O(1)$\\
  \textbf{Procedure:}
  \begin{enumerate}
    \item $\vert 0 \rangle^{\otimes n} \vert 0 \rangle$   initial state
    \item $\rightarrow \frac{1}{\sqrt{2^n}} \sum_{x=0}^{2^n-1} \vert x \rangle [\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}}]$  apply $H^{\otimes n}$ to the first $n$ qubits, and $HX$ to the last $qubit$
    \item $\rightarrow [(2\vert s \rangle \rangle s \vert - \hat{I})\hat{O}]^R \sum_{x=0}^{2^n-1} \vert x \rangle [\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}}] \approx \vert x_0 \rangle [\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}}]$   apply the Grover iteration $R \approx \lceil \frac{\pi \sqrt{2^n}}{4}$ times.
    \item $\rightarrow x_0$   measure the first $n$ qubits
  \end{enumerate}
\end{tcolorbox}

\subsection{\tl{Example}}
Ας δούμε τώρα και ένα παράδειγμα του κβαντικού αλγορίθμου του $Grover$. Έστω ότι έχουμε μια μη δομημένη βάση δεδομένων με 4 στοιχεία και θέλουμε να βρούμε το στοιχείο που αντιστοιχεί στην βασική κατάσταση $\vert x_i \rangle = \vert 01 \rangle$.
Αρχικά θα έχουμε έναν κβαντικό καταχωρητή με 2 $qubits$ και θα ψάξουμε τον αριθμό που αντιστοιχεί στον αριθμό 1, με βάση την κατάσταση του. Θα εκτελέσουμε ένα ένα όλα τα βήματα που είδαμε παραπάνω:\\
\textbf{Βήμα 1ο}\\
Αρχίζουμε με τον κβαντικό καταχωρητή στην κατάσταση $\vert 00 \rangle$ και τον θέτουμ σε υπέρθεση βασικών καταστάσεων. Το πλάτος πιθανότητας για κάθε κατάσταση πρέπει να είναι το ίδιο όποτε χρησιμοποιούμε δύο κβαντικές πύλες $H$.
Άρα θα έχουμε:
\begin{flalign*}
  \vert s \rangle &= H \otimes H \vert 00 \rangle = \begin{bmatrix}
    [\frac{1}{2} & \frac{1}{2} & \frac{1}{2} & \frac{1}{2}\\
    \frac{1}{2} & -\frac{1}{2} & \frac{1}{2} & -\frac{1}{2}\\
    \frac{1}{2} & \frac{1}{2} & -\frac{1}{2} & -\frac{1}{2}\\
    \frac{1}{2} & -\frac{1}{2} & -\frac{1}{2} & \frac{1}{2}]
  \end{bmatrix}
  \begin{bmatrix}
    1\\
    0\\
    0\\
    0
  \end{bmatrix} = \frac{1}{2}\begin{bmatrix}
    1\\
    1\\
    1\\
    1
\end{bmatrix} \Rightarrow &&\\
&= \frac{1}{2}(\vert 00 \rangle + \vert 01 \rangle + \vert 10 \rangle + \vert 11 \rangle)
\end{flalign*}
Άρα έχουμε φέρει τον καταχωρητή στη βασική μορφή υπέρθεσης που θέλουμε. Δεδομένου ότι ψάχνουμε την $\vert 01 \rangle$, θέλουμε να φέρουμε τον καταχωρητή σε τέτοια κατάσταση ώστε ο συντελεστής της $\vert 01 \rangle$ να είναι πολύ κοντά στη μονάδα.\\

\textbf{Βήμα 2ο:}\\
Τώρα δρα ο τελεστής $\hat{O} = \hat{I} - 2\vert x_i \rangle \rangle x_i \vert$ όπου έχουμε:
\begin{flalign*}
  \hat{O} = \hat{I} - 2 \vert x_i \rangle \rangle x_i \vert &= \begin{bmatrix}
    1 & 0 & 0 & 0\\
    0 & 1 & 0 & 0\\
    0 & 0 & 1 & 0\\
    0 & 0 & 0 & 1
\end{bmatrix} - 2 \begin{bmatrix}
  0\\
  1\\
  0\\
  0
\end{bmatrix}
\begin{bmatrix}
  0 & 1 & 0 & 0
\end{bmatrix} =&&\\
&= \begin{bmatrix}
  1 & 0 & 0 & 0\\
  0 & 1 & 0 & 0\\
  0 & 0 & 1 & 0\\
  0 & 0 & 0 & 1
\end{bmatrix} - 2\begin{bmatrix}
  0 & 0 & 0 & 0\\
  0 & 1 & 0 & 0\\
  0 & 0 & 0 & 0\\
  0 & 0 & 0 & 0
\end{bmatrix} =&&\\
&= \begin{bmatrix}
  1 & 0 &  0 & 0\\
  0 & -1 & 0 & 0\\
  0 &  0 & 1 & 0\\
  0 &  0 & 0 & -1
\end{bmatrix}
\end{flalign*}
Άρα
\begin{flalign*}
  \vert s' \rangle = \hat{O} \vert s \rangle = \frac{1}{2}\begin{bmatrix}
    1 & 0  & 0 & 0\\
    0 & -1 & 0 & 0\\
    0 & 0  & 1 & 0\\
    0 & 0  & 0 & 1
\end{bmatrix}
\begin{bmatrix}
  1\\
  1\\
  1\\
  1
\end{bmatrix} = \frac{1}{2}\begin{bmatrix}
  1\\
  -1\\
  1\\
  1
\end{bmatrix} = \frac{1}{2}(\vert 00 \rangle - \vert 01 \rangle + \vert 10 \rangle + \vert 11 \rangle)
\end{flalign*}
Και όπως βλέπουμε το πρόσημο της ζητούμενης κατάστασης έχει αλλάξει.\\
\textbf{Βήμα 3ο}\\
Τώρα επιδρά ο τελεστής $\hat{G} = 2\vert s \rangle \rangle s \vert - \hat{I}$
\begin{flalign*}
  \hat{G} = 2\vert s \rangle \rangle s \vert - \hat{I} &= 2\frac{1}{2}\begin{bmatrix}
    1\\
    1\\
    1\\
    1
\end{bmatrix} \frac{1}{2}\begin{bmatrix}
  1 & 1 & 1 & 1
\end{bmatrix} - \begin{bmatrix}
  1 & 0 & 0 & 0\\
  0 & 1 & 0 & 0\\
  0 & 0 & 1 & 0\\
  0 & 0 & 0 & 1
\end{bmatrix} =&&\\
&= \frac{1}{2} \begin{bmatrix}
  1 & 1 & 1 & 1\\
  1 & 1 & 1 & 1\\
  1 & 1 & 1 & 1\\
  1 & 1 & 1 & 1
\end{bmatrix} - \begin{bmatrix}
  1 & 0 & 0 & 0\\
  0 & 1 & 0 & 0\\
  0 & 0 & 1 & 0\\
  0 & 0 & 0 & 1
\end{bmatrix} =&&\\
&= \frac{1}{2}\begin{bmatrix}
  -1 &  1 &  1 &  1\\
   1 & -1 &  1 &  1\\
   1 &  1 & -1 &  1\\
   1 &  1 &  1 & -1
\end{bmatrix}
\end{flalign*}

Με τη δράση της $\hat{G}$ το αποτέλεσμα που παίρνουμε είναι:
\begin{align*}
  \vert s" \rangle = \hat{G} \vert s' \rangle = \frac{1}{4} \begin{bmatrix}
    -1 &  1 &  1 &  1\\
     1 & -1 &  1 &  1\\
     1 &  1 & -1 &  1\\
     1 &  1 &  1 & -1
\end{bmatrix} \begin{bmatrix}
  1\\
  -1\\
  1\\
  1
\end{bmatrix} = \frac{1}{4} \begin{bmatrix}
  0\\
  4\\
  0\\
  0
\end{bmatrix} = \begin{bmatrix}
  0\\
  1\\
  0\\
  0
\end{bmatrix} = \vert 01 \rangle
\end{align*}

Αν μετρήσουμε λοιπόν την κατάσταση του κβαντικού καταχωρητή, είναι βέβαιο ότι θα βρούμε την κατάσταση $\vert x_i \rangle = \vert 01 \rangle$, όπου ο αριθμός των επαναλήψεων είναι $(\frac{\pi}{4}\sqrt{N}) - 0.5 \cong 1 $

\section{\tl{Summary of Quantum Algorithms}}
Σε αυτή την ενότητα, θα προσπαθήσουμε να κάνουμε μια μικρή περίληψη των κβαντικών αλγορίθμων που είδαμε μέχρι τώρα.
Αρχικά είδαμε πως μπορούμε να χρησιμοποιήσουμε έναν πιθανοτικό αλγόριθμο σε έναν κβαντικό υπολογιστή. Το βασικότερο εδώ είναι ότι η συνολική πιθανότητα να μεταβούμε από μια κατάσταση σε μια άλλη, είναι ίση με τα τετράγωνα των κβαντικών πλατών για τις πιθανότητες αυτές. Για να βρούμε λοιπόν τη συνολική πιθανότητα, αντί να προσθέσουμε τις πιθανότηες για τα διαφορετικά μονοπάτια (για να φτάσουμε από μια κατάσταση σε μια άλλη), προσθέτουμε τα κβαντικά πλάτη.
Στη συνέχεια είδαμε μερικά πράγματα για τον κβαντικό παραλληλισμό, που αποτελεί την βάση για αρκετούς κβαντικούς αλγορίθμους. Αυτό που μας επιτρέπει ο κβαντικός παραλληλισμός είναι να ελέγξουμε μια συνάρτηση $f(x)$ για πολλές διαφορετικές τιμές του $x$ ταυτόχρονα. Αυτό επιτυγχάνεται με τη χρήση 2 $qubits$ και μια ακολουθία λογικών πυλών. Στο τελικό στάδιο, έχουμε τις πληροφορίες για την $f(0)$ και την $f(1)$ ταυτόχρονα.
Ο πρώτος κανονικός κβαντικός αλγόριθμος που υπήρξε, ήταν ο αλγόριθμος του $Deutsch$. Σε αντίθεση με τον κβαντικό παραλληλισμό, εδώ ο στόχος του αλγορίθμου είναι να ορίσουμε την τιμή της $f(0) \oplus f(1)$. Έχουμε περίπου την ίδια βάση με τον κβαντικό παραλληλισμό. Έχουμε πάλι 2 $qubits$ όπου το πρώτο $qubit$ είναι το $qubit$ ελέγχου και η επίδραση των κβαντικών πυλών στο δεύτερο $qubit$ εξαρτάται από το πρώτο. Στη συνέχεια, κωδικοποιώντας τις τιμές του δεύτερου $qubit$ με βάση το πρώτο, προσδιορίζουμε την $f(0) \oplus f(1)$, προσδιορίζοντας τους συντελεστές φάσης μεταξύ των $\vert 0 \rangle$ και $\vert 1 \rangle$.
Η γενίκευση του αλγορίθμου του $Deutsch$, ή μάλλον του προβλήματος του $Deutsch$, είναι το πρόβλημα του $Deutsch-Josza$. Πάλι έχουμε σαν είσοδο μια άγνωστη συνάρτηση $f$, όπου αυτή τη φορά θέλουμε να αποφασίσουμε τι είναι η $f$, δηλαδή αν είναι $constant$ ή $balanced$. Εδώ έχουμε $νn-qubits$ πύλες $Hadamard$. Στο τέλος του αλγορίθμου η μέτρηση του πρώτου καταχωρητή γίνεται σε υπολογιστική βάση και εάν η $f$ είναι $constant$, τότε το πλάτος της τελικής κατάσταση; θα είναι είτε +1 είτε -1 και άρα η μέτρηση του πρώτου καταχωρητή θα μας επιστρέψει σίγουρα όλα τα 0. Αν αντίστοιχα η $f$ είναι $balanced$ και οι συνιστώσες των πλατών αλληλοαναιρούνται, το συνολικό πλάτος θα είναι 0 και η τελική μέτρηση στον πρώτο καταχωρητή θα μας δώσει όλες τις μη μηδενικές τιμές. Επομένως ανάλογα με τη μέτρηση του καταχωρητή μπορούμε να αποφανθούμε για το τι είναι η $f$.
Ο επόμενος αλγόριθμος είναι ο αλγόριθμος του $Simon$. Αυτός ο αλγόριθμος λύνει ένα αρκετά διαφορετικό πρόβλημα. Σε μια άγνωστη συνάρτηση $f: 0,1^n \rightarrow X$, υπάρχει $string$ $s$ τέτοιο ώστε $f(x) = f(y)$ ανν $x = y$ ή $x = y \oplus s$. Ο αναμενόμενος αριθμός εκτιμήσεων της $f$ είναι λιγότερος από $n$. Επίσης ο αλγόριθμος μπορεί να εφαρμοστεί είτε εάν γνωρίζουμε τη διάσταση $m$ του υποσυνόλου στο οποίο κάνουμε την αναζήτηση, είτε όχι.
Ο τελευταίος αλγόριθμος που είδαμε είναι ο αλγόριθμος του $Grover$. Είναι αρκετά πιο πολύπλοκος από τους προηγούμενους και είναι ο πρώτος κβαντικός αλγόριθμος αναζήτησης. Με λίγα λόγια ο συγκεκριμένος αλγόριθμος μας δίνει τη δυνατότητα να βρούμε ένα στοιχείο μέσα σε μια βάση $N$ στοιχείων με $\sqrt{N}$ βήματα. Στον αλγόριθμο του $Grover$ χρησιμοποιούμε μια συνάρτηση $f$ που παίρνει τιμές 0 και 1 (κβαντικό $oracle$). Το $oracle$ επιδρά στις βασικές κατάστασεις ενός τυχαίου σημείου $x$, δηλαδή στις καταστάσεις $\vert x \rangle$. Αν η βασική αυτή κατάσταση αντιστοιχεί στην κατάσταση του στοιχείου που ψάχνουμε, τότε της αλλάζει το πρόσημο, αλλιώς το αφήνει ως έχει.

Θα μπορούσαμε να πούμε ότι υπάρχουν τρεις κλάσεις κβαντικών αλγορίθμων. Η πρώτη είναι η κλάση των αλγορίθμων που βασίζονται στον μετασχηματισμό $Fourier$ (θα δούμε λεπτομέρειες στο επόμενο κεφάλαιο). Ένα τέτοιο παράδειγμα είναι ο αλγόριθμος του $Deutsch-Josza$. Η δεύτερη κλάση είναι η κάση των κβαντικών αλγορίθμων αναζήτησης, όπως ο αλγόριθμος του $Grover$. Και η τελευταία κλάση είναι οι κβαντικοί αλγόριθμοι προσομοίωσης ($quantum$ $simulation$), όπου ένας κβαντικός υπολογιστής χρησιμοποιείται για να προσομοιώσει ένα κβαντικό σύστημα~\cite{Nielsen:2011:QCQ:1972505}.
