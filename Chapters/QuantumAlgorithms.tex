\chapter{\tl{Quantum Algorithms}}

\section{\tl{Probabilistic Versus Quantum Algorithms}}
Οι πιθανοτικοί αλγόριθμοι έχουν ευρεία χρήση στη θεωρητική πληροφορική καθώς χρησιμοποιούνται στη λύση πολλών διαφορετικών προβλημάτων. Σε αυτό το κεφάλαιο θα δούμε πως είναι δυνατό οι κβαντικοί αλγόριθμοι να αποτελέσουν μια γενίκευση των πιθανοτικών αλγορίθμων.

Θα ξεκινήσουμε με ένα απλό παράδειγμα ενός πιθανοτικού αλγόριθμου. Το παρακάτω σχήμα απεικονίζει τα πρώτα δύο βήματα ενός τέτοιου υπολογισμού σε έναν καταχωρητή ο οποίος μπορεί να βρίσκεται σε μια από τις τέσσερις καταστάσεις.

\begin{tikzpicture}[
  ->,
  >=stealth',
  shorten >=1pt,
  auto,
  node distance=2.8cm,
  semithick,
  every state/.style={fill=black,draw=none,text=white},
]

\node[shape=circle,draw=black] at (0,0) (0) {0};
1
\node[shape=circle,draw=black] at (3,1.8) (a) {0};
\node[shape=circle,draw=black] at (3,0.8) (b) {1};
\node[shape=circle,draw=black] at (3,-0.8) (c) {2};
\node[shape=circle,draw=black] at (3,-1.8) (d) {3};


\node[shape=circle,draw=black] at (6,1.8) (a1) {0};
\node[shape=circle,draw=black] at (6,0.8) (b1) {1};
\node[shape=circle,draw=black] at (6,-0.8) (c1) {2};
\node[shape=circle,draw=black] at (6,-1.8) (d1) {3};

\path[every node/.style={sloped,anchor=south,auto=false}]
     (0) edge              node {$p_{0,0}$} (a)
     (0) edge              node {$p_{0,1}$} (b)
     (0) edge              node {$p_{0,2}$} (c)
     (0) edge              node {$p_{0,3}$} (d);

\path[every node/.style={sloped,anchor=south,auto=false}]
     (a) edge              node {$q_{0,0}$} (a1)
     (a) edge              node {$q_{0,1}$} (b1)
     (a) edge              node {} (c1)
     (a) edge              node {} (d1)

     (b) edge              node {} (a1)
     (b) edge              node {} (b1)
     (b) edge              node {} (c1)
     (b) edge              node {} (d1)

     (c) edge              node {} (a1)
     (c) edge              node {} (b1)
     (c) edge              node {} (c1)
     (c) edge              node {$q_{2,3}$} (d1)

     (d) edge              node {} (a1)
     (d) edge              node {} (b1)
     (d) edge              node {} (c1)
     (d) edge              node {$q_{3,3}$} (d1);

\end{tikzpicture}


Αρχικοποιούμε τον καταχωρητή στο $0$. Μετά το πρώτο βήμα, ο καταχωρητής είναι στην κατάσταση $j$ με πιθανότητα $p_{0,j}$. Υποθέτωντας ότι θέλουμε να βρούμε τη συνολική πιθανότητα ότι ο υπολογισμός τερματίζει στην κατάσταση $3$ μετά το δεύτερο βήμα. Αυτός ο υπολογισμός γίνεται σε δύο στάδια. Αρχικά υπολογίζουμε την πιθαντότητα που σχετίζεται με τα διαφορετικά υπολογιστικά μονοπάτια τα οποία τερματίζουν στην κατάσταση $3$ και στη συνέχεια προσθέτωντας τις πιθανότητες όλων αυτών των διαφορετικών μονοπατιών. Μπορούμε να μεταβούμε από την κατάσταση $0$ στην κατάσταση $j$ και στη συνέχεια από την κατάσταση $j$ στην κατάσταση $3$ με ένα από τα τέσσερα $j \epsilon {0, 1, 2, 3}$. Όπως είναι ήδη γνωστό η πιθανότητα που σχετίζεται με καθένα από τα μονοπάτια βρίσκεται εάν πολλαπλασιάσουμε την πιθανότητα $p_{0,j}$ της μετάβασης από την $0$ στην $j$ με την πιθανότητα $q_{j,3}$ της μετάβασης από τη $j$ στην $3$. Η συνολική πιθανότητα να τερματίσουμε στην $3$ δίνεται αν προσθέσουμε τις τέσσερις πιθανότητες που προκύπτουν.
Όμως οι πιθανότητες αυτές που προκύπτουν είναι τα τετράγωνα των κβαντικών πιθανοτικών πλατών. Δηλαδή $p_{0,j} = \vert \alpha_{0,j} \vert ^2$ και $q_{j,k} = \vert \beta_{j,k} \vert^2$.
Άρα το τελικό αποτέλεσμα που προκύπτει είναι~\cite{Kaye:2007:IQC:1206629}:

\begin{align*}
  prob = \sum_{j} p_{0,j}q_{j,3}
\end{align*}

Και εδώ έχουμε το προηγούμενο σχήμα με χρήση κβαντικών πλατών.

\begin{tikzpicture}[
  ->,
  >=stealth',
  shorten >=1pt,
  auto,
  node distance=2.8cm,
  semithick,
  every state/.style={fill=black,draw=none,text=white},
]

\node[shape=circle,draw=black] at (0,0) (0) {0};
1
\node[shape=circle,draw=black] at (3,2) (a) {0};
\node[shape=circle,draw=black] at (3,1) (b) {1};
\node[shape=circle,draw=black] at (3,-1) (c) {2};
\node[shape=circle,draw=black] at (3,-2) (d) {3};


\node[shape=circle,draw=black] at (6,2) (a1) {0};
\node[shape=circle,draw=black] at (6,1) (b1) {1};
\node[shape=circle,draw=black] at (6,-1) (c1) {2};
\node[shape=circle,draw=black] at (6,-2) (d1) {3};

\path[every node/.style={sloped,anchor=south,auto=false}]
     (0) edge              node {$\vert \alpha_{0,0} \vert^2$} (a)
     (0) edge              node {$\vert \alpha_{0,1} \vert^2$} (b)
     (0) edge              node {$\vert \alpha_{0,2} \vert^2$} (c)
     (0) edge              node {$\vert \alpha_{0,3} \vert^2$} (d);

\path[every node/.style={sloped,anchor=south,auto=false}]
     (a) edge              node {$\vert \beta{0,0} \vert^2$} (a1)
     (a) edge              node {} (b1)
     (a) edge              node {} (c1)
     (a) edge              node {} (d1)

     (b) edge              node {} (a1)
     (b) edge              node {} (b1)
     (b) edge              node {} (c1)
     (b) edge              node {} (d1)

     (c) edge              node {} (a1)
     (c) edge              node {} (b1)
     (c) edge              node {} (c1)
     (c) edge              node {} (d1)

     (d) edge              node {} (a1)
     (d) edge              node {} (b1)
     (d) edge              node {} (c1)
     (d) edge              node {} (d1);

\end{tikzpicture}

Αν μετρήσουμε την κατάσταση αμέσως μετά το πρώτο βήμα του υπολογισμού, η πιθανότητα να προκύψει το αποτέλεσμα 2 είναι:

\begin{align*}
  prob = \vert \alpha_{0,2} \vert ^2 = p_{0,2}
\end{align*}

Και τελικά η συνολική πιθανότητα να μετρήσουμε το αποτέλεσμα 3 μετά το δεύτερο βήμα είναι:

\begin{flalign*}
  prob_3 &= \sum_{j} \vert \alpha_{0,j} \vert^2 \vert \beta_{j,3} \vert^2&&\\
  &= \sum_{j} \vert \alpha_{0,j}\beta_{j,3} \vert^2 &&
\end{flalign*}

Παρότι στο συγκεκριμένο παράδειγμα κάναμε τις μετρήσεις αμέσως μετά από κάθε βήμα, σε ένα κβαντικό αλγόριθμο αυτό δεν είναι εφικτό. Αυτό σημαίνει ότι τα κβαντικά πλάτη θα μπορούσαν να επηρεάσουν το τελικό αποτέλεσμα. Δηλαδή αν μετρήσουμε τη συνολική πιθαντότητα να φτάσουμε στην τελική κατάσταση 3, μετά το δεύτερο βήμα, το αποτέλεσμα είναι διαφορετικό από ότι πριν γιατί δεν γνωρίζουμε τη διαδρομή που ακολούθησε ο αλγόριθμος μέχρι να φτάσει εκεί. Σε αυτή τη περίπτωση λοιπόν, αντί να προσθέσουμε τις πιθανότητες, προσθέτουμε τα πλάτη των πιθανοτήτων. Άρα η πιθανότητα να φτάσουμε στο αποτέλεσμα 3 μετά το δεύτερο βήμα προκύπτει από το τετράγωνο του συνολικού πλάτους της πιθαντότητας αυτής.

\begin{align*}
  prob_3 = \vert \sum_{j} \alpha_{0,j} \beta_{j,3} \vert ^2
\end{align*}
Και λίγο πιο παραστατικά:

\begin{tikzpicture}[
  ->,
  >=stealth',
  shorten >=1pt,
  auto,
  node distance=2.8cm,
  semithick,
  every state/.style={fill=black,draw=none,text=white},
]

\node[shape=circle,draw=black] at (0,0) (0) {$\vert 0 \rangle$};
1
\node[shape=circle,draw=black] at (3,2) (a) {$\vert 0 \rangle$};
\node[shape=circle,draw=black] at (3,1) (b) {$\vert 1 \rangle$};
\node[shape=circle,draw=black] at (3,-1) (c) {$\vert 2 \rangle$};
\node[shape=circle,draw=black] at (3,-2) (d) {$\vert 3 \rangle$};


\node[shape=circle,draw=black] at (6,2) (a1) {$\vert 0 \rangle$};
\node[shape=circle,draw=black] at (6,1) (b1) {$\vert 1 \rangle$};
\node[shape=circle,draw=black] at (6,-1) (c1) {$\vert 2 \rangle$};
\node[shape=circle,draw=black] at (6,-2) (d1) {$\vert 3 \rangle$};

\path[every node/.style={sloped,anchor=south,auto=false}]
     (0) edge              node {$\alpha_{0,0}$} (a)
     (0) edge              node {$\alpha_{0,1}$} (b)
     (0) edge              node {$\alpha_{0,2}$} (c)
     (0) edge              node {$\alpha_{0,3}$} (d);

\path[every node/.style={sloped,anchor=south,auto=false}]
     (a) edge              node {$\beta_{0,0}$} (a1)
     (a) edge              node {$\beta_{0,1}$} (b1)
     (a) edge              node {} (c1)
     (a) edge              node {} (d1)

     (b) edge              node {} (a1)
     (b) edge              node {} (b1)
     (b) edge              node {} (c1)
     (b) edge              node {} (d1)

     (c) edge              node {} (a1)
     (c) edge              node {} (b1)
     (c) edge              node {} (c1)
     (c) edge              node {$\beta_{2,3}$} (d1)

     (d) edge              node {} (a1)
     (d) edge              node {} (b1)
     (d) edge              node {} (c1)
     (d) edge              node {$\beta_{3,3}$} (d1);

\end{tikzpicture}

Όπως μπορούμε να δούμε, οι κλασσικοί πιθανοτικοί αλγόριθμοι μπορούν να προσομοιαστούν από τους κβανιτκούς αλγορίθμους. Είναι εφικτή όμως η αντίστροφη διαδικασία; Η αντικατάσταση μιας κβαντικής πύλης με μια πιθανοτική κλασσική πύλη μπορεί να δώσει τελείως διαφορετικά αποτελέσματα, άρα δεν είναι μια εφικτή λύση. Ωστόσο σε κάποιες συγκεκριμένες περιπτώσεις όπως τα κβαντικά κυκλώματα που χρησιμοποιούν μόνο πύλες $CNOT, H, X, Y, Z, T$, μπορούν να προσομοιαστούν σε έναν κλασσικό υπολογιστή. Μπορούμε να συμπεράνουμε ότι είναι πολύ πιθανό οι κβαντικοί αλγόριθμοι να επιλύουν πολύ πιο γρήγορα τα όποια προβλημάτα σε σχέση με τους κλασσικούς πιθανοτικούς αλγορίθμους.

\section{\tl{Quantum Parallelism}}

Ο κβαντικός παραλληλισμός ($parallelism$) αποτελεί βασικό στοιχείο για πολλούς αλγόριθμους. Πολύ γενικά θα μπορούσαμε να πούμε ότι επιτρέπει σε έναν κβαντικό υπολογιστή να "αξιολογήσει" μια συνάρτηση $f(x)$ για πολλές διαφορετικές τιμές του $x$ ταυτόχρονα.

Έστω ότι έχουμε μια συνάρτηση $f(x): {0,1} \rightarrow {0,1}$. Σε έναν κβαντικό υπλογιστή, μπορούμε να υπολογίσουμε τη συνάρτηση αυτή θεωρώντας έναν κβαντικό υπολογιστή με δύο $qubits$ που ξεκινάει με την κατάσταση $\vert x,y \rangle$. Με μια ακολουθία λογικών πυλών μπορούμε να το μετασχηματίσουμε στην κατάσταση $\vert x,y \oplus f(x \rangle)$. Ο πρώτος καταχωρητής ονομάζεται $data register$ και ο δέυτερος $target register$. Ονομάζομουν τον μετασχηματισμό $U_f = \vert x,y \rangle \rightarrow \vert x,y \oplus f(x) \rangle$.

Έστω ένα κύκλωμα που εφαρμόζει την $U_f$ σε μια είσοδο αλλά όχι σε υπολογιστική βάση. Τότε ο $data register$ είναι προετοιμασμένος για την υπέρθεση $(\vert 0 \rangle + \vert 1 \rangle)/\sqrt{2}$ το οποίο μπορούμε να το δημιουργήσουμε με μια πύλη $Hadamard$. Και εφαρμόζοντας την $U_f$ έχουμε~\cite{Nielsen:2011:QCQ:1972505}:

\begin{align*}
  \frac{\vert 0, f(0)\rangle + \vert 1, f(1)\rangle} {\sqrt{2}}.
\end{align*}

Και εδώ είναι το σημαντικότερο σημείο, γιατί οι διαφορετικοί όροι περιέχουν πληροφορίες τόσο για την $f(0)$ αλλά και για την $f(1)$ σχεδόν ταυτόχρονα. Αντίθετα με τον κλασσικό παραλληλισμό, όπου πολλαπλά κυκλώματα προσπαθούσαν να υπολογίσουν την $f(x)$ ταυτόχρονα, εδώ ένα και μόνο κύκλωμα	υπολογίζει πολλαπλές τιμές χρησιμοποιώντας τη δυνατότητα των κβαντικών υπλογιστών να είναι σε υπερθέσεις διαφορετικών καταστάσεων.

Η παραπάνω διαδικασία/παράδειγμα θα μπορούσε να γενικευτεί σε συναρτήσεις με έναν τυχαίο αριθμό $bits$ χρησιμοποιώντας τη γενική διαδικασία $Hadamard Transform$ ή $Walsh-Hadamard Transform$. Η συγκεκριμένη διαδικασία είναι επί της ουσίας $n$ πύλες $Hadamard$ που δρουν παράλληλα σε $n qubits$.

Παρότι ο κβαντικός παραλληλισμός μας δίνει τη δυνατότηα να ελέγξουμε όλες τις πιθανές τιμές της $f$ ταυτόχρονα, δεν μπορεί να χρησιμοποιηθεί απευθείας.
 Στο παράδειγμα μας η μέτρηση της κατάστασης θα επέστρεφε είτε $\vert 0, f(0\rangle)$ είτε $\vert 1, f(1)\rangle$ μόνο. Στη γενική περίπτωση η μέτρηση της κατάστασης $\sum_{x} \vert x, f(x) \rangle$ θα έδινε μόνο $f(x)$ για μια μοναδική τιμή $x$, κάτι που θα μπορούσε να κάνει και ένας κλασσικός υπολογιστής. Ένας κβαντικός υπολογισμός, απαιτεί περισσότερα από έναν κβαντικό παραλληλισμό καθώς χρειάζεται την δυνατότητα να αντλεί πληροφορίες για παραπάνω από μια τιμή της $f(x)$ από την υπέρθεση της κατάστασης $\sum_{x} \vert x, f(x) \rangle$.

\section{\tl{Deutsch's Algorithm}}

Ο κβαντικός αλγόριθμος του $Deutsch$ είναι ένας από τους πρώτους και πιο απλούς κβαντικούς αλγορίθους. Ο κβαντικός αλγόριθμος του $Deutsch$ συνδυάζει τον κβαντικό παραλληλισμό που είδαμε παραπάνω με κάποιες βασικά στοχεία της κβαντομηχανικής γνωστά ως $"interference"$. Αρχικά θα χρησιμοποιήσουμε πάλι μια πύλη $Hadamard$ για να ετοιμάσουμε το πρώτο $qubit$ της υπέρθεσης $\frac{\vert 0 \rangle + \vert 1 \rangle}{\sqrt{2}}$, αλλά τώρα ετοιμάζουμε και ένα δέυτερο $qubit, y$ σαν την υπέρθεση $\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}}$ χρησιμοποιώντας μια πυλη $Hadamard$ στην κατάσταση $\vert 1 \rangle$.
Παρακάτω η διάταξη του αλγορίθμου:\\
\\
\includegraphics[width=10cm]{figures/DeutschAlgo.png}\\
\\
Ας δούμε λίγο επιγραμματικά τον αλγόριθμο. Ο στόχος του αλγορίθμου δεν είναι να υπολογίσουμε όλες τις ξεχωριστές τιμές της $f(x)$, αλλά να ορίσουμε την τιμή της $f(0) \oplus f(1)$. Όπως είπαμε ξεκινάμε περίπου όπως στο παράδειγμα για τον κβαντικό παραλληλισμό. Αρχικά η κατάσταση του καταχωρητή	είναι $\vert 01 \rangle$. Στη συνέχεια δρουν οι δύο πύλες $Hadamard$. Μετά ξεκινάει ο συνδυασμός κβαντικών πυλών $U_f$ και ακολουθεί η πύλη στο πρώτο $qubit$. Μετράμε την κατάσταση του πρώτου $qubit$. Αν είναι στην κατάσταση $\vert 0 \rangle$, τότε η $f(x)$ είναι σταθερή~\cite{Gudder2000-GUDUZA} ενώ αν βρεθεί στην κατάσταση $\vert 1 \rangle$ η $f(x)$ είναι ισορροπημένη~\cite{Bellac:2006:SIQ:1202004}.

Ας δούμε λίγο πιο αναλυτικά τη λειτουργία του αλγορίθμου. Αρχικά δημιουργώντας την κβαντική εκδοχή του κυκλώματατος για την $f$, μπορούμε να δώσουμε κβαντικά $qubits$ σαν είσοδο. Επίσης έχουμε ορίσει την $U_f$ τέτοια ώστε αν θέσουμε το δεύτερο $qubit$ στην κατάσταση $\vert y \rangle = \vert 0 \rangle$, τότε το πρώτο $qubit$ που είναι στην κατάσταση $\vert x \rangle = \vert 0 \rangle$ θα δώσει $\vert 0 \oplus f(0) \rangle = \vert f(0) \rangle$ στο δεύτερο $qubit$ και αν έχουμε $\vert x \rangle = \vert 1 \rangle$ τότε το πρώτο $qubit$ θα μας δώσει
$\vert f(1) \rangle$. Βέβαια τα $qubits$ εισόδου δεν είναι απαραίτητο να είναι σε μια μόνο κατάσταση, αλλά μπορεί να βρίσκονται σε μια υπέρθεση των $\vert 0 \rangle$ και $\vert 1 \rangle$. Κρατώντας το δεύτερο $qubit$ στην κατάσταση $\vert y \rangle = \vert 0 \rangle$, θέτουμε το πρώτο $qubit$ σαν την υπέρθεση των δυο καταστάσεων, άρα:

 \begin{align*}
   \vert x \rangle = \frac{1}{\sqrt{2}}\vert 0 \rangle + \frac{1}{\sqrt{2}} \vert 1 \rangle
 \end{align*}

Επομένως η είσοδος που θα δώσουμε στην $U_f$ είναι:
\begin{align}
  (\frac{1}{\sqrt{2}}\vert 0 \rangle + \frac{1}{\sqrt{2}}\vert 1 \rangle)\vert 0 \rangle\\
  = \frac{1}{\sqrt{2}}\vert 0 \rangle \vert 0 \rangle + \frac{1}{\sqrt{2}}\vert 1 \rangle \vert 0 \rangle
\end{align}

Η έξοδος της $U_f$ είναι η εξής:

\begin{flalign}
   U_f (\frac{1}{\sqrt{2}}\vert 00 \rangle + \frac{1}{\sqrt{2}} \vert 10 \rangle) =&
  =\frac{1}{\sqrt{2}}U_f \vert 00 \rangle + \frac{1}{\sqrt{2}}U_f \rangle 10 \vert=&&\\
  &=\frac{1}{\sqrt{2}}\vert 0 \rangle \vert0 \oplus f(0) \rangle + \frac{1}{\sqrt{2}} \vert 1 \rangle \vert 0 \oplus f(1)\rangle = &&\\
  &= \frac{1}{\sqrt{2}} \vert 0 \rangle \vert f(0) \rangle + \frac{1}{\sqrt{2}} \vert 1 \rangle \vert 0 \oplus f(1) \rangle
\end{flalign}

Αν μετρούσαμε τώρα την έξοδο σε υπολογιστική βάση, το αποτέλεσμα θα ήταν είτε $\vert 0 \rangle \vert f(0) \rangle$ είτε $\vert 1 \rangle \vert 1 \oplus f(1) \rangle$. Μετά την μέτρηση η κατάσταση της εξόδου θα είναι είτε $\vert f(0) \rangle$ είτε $\vert f(1) \rangle$. Όμως ο στόχος του αλγορίθμου δεν είναι να υπολογίσουμε όλες τις διαφορετικές τιμές της $f(x)$. Ο αλγόριθμος περιγράφει πως μπορούμε	 να χρησιμοποιήσουμε τους κβαντικούς μηχανισμούς ($interference$) για να βρουμε μια γενική πληροφορία για την $f$ και πως μπορούμε να το κάνουμε αυτό πολύ πιο αποδοτικά σε σχέση με τον κλασσικό τρόπο.
Αρχικά το πρώτο $bit$ είναι στην κατάσταση $\vert 0 \rangle$ και το δεύτερο στην κατάσταση $\frac{\vert 0 \rangle - \vert 1 \rangle}{2}$. Πριν επιδράσει καμία πύλη, έχουμε ότι
\begin{align}
  \vert \psi_0 \rangle = \vert 0 \rangle(\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}})
\end{align}

Αμέσως μετά την επίδραση της πρώτης πύλης $Hadamard$ στο πρώτο $qubit$ η κατάσταση γίνεται:

\begin{flalign}
  \vert \psi_1 \rangle &= (\frac{1}{\sqrt{2}} \vert 0 \rangle) =&&\\
  &= \frac{1}{\sqrt{2}} \vert 0 \rangle (\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}}) + \frac{1}{\sqrt{2}}\vert 1 \rangle (\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}})
\end{flalign}

Και στη συνέχεια επιδρά ο συνδυασμός πυλών $U_f$:

\begin{flalign}
  \vert \psi_2 \rangle &= \frac{(-1)^{f(0)}}{\sqrt{2}}\vert 0 \rangle (\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}}) + \frac{(-1)^{f(1)}}{\sqrt{2}} \vert 1 \rangle (\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}}) =&&\\
  &= (\frac{(-1)^{f(0)} \vert 0 \rangle + (-1)^{f(1)} \vert 1 \rangle}{\sqrt{2}})(\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}}) =&&\\
  &= (-1)^{f(0)} (\frac{\vert 0 \rangle + (-1)^{f(0) \oplus f(1)} \vert 1 \rangle}{\sqrt{2}})(\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}})
\end{flalign}

Εδώ έχουμε μερικές διαφορετικές περιπτώσεις. Αν η $f$ είναι σταθερή συνάρτηση, τότε έχουμε:

\begin{align}
  \vert \psi_2 \rangle = (-1)^{f(0)} (\frac{\vert 0 \rangle + \vert 1 \rangle}{\sqrt{2}})(\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}})
\end{align}

Και άρα η η τελευταία πύλη $Hadamard$ στο πρώτο $qubit$ μας δίνει το εξής:

\begin{align}
  \vert \psi_3 \rangle = (-1)^{f(0)} \vert 0 \rangle (\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}})
\end{align}

Αν όμως η $f$ είναι ισορροπημένη, τότε έχουμε:
\begin{align}
  \vert \psi_2 \rangle = (-1)^{f(0)}(\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}})(\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}})
\end{align}
και άρα η τελευταία πύλη μας δίνει:

\begin{align}
  \vert \psi_3 \rangle = (-1)^{f(0)} \vert 1 \rangle (\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}})
\end{align}

Προσπαθώντας να γενικοποιήσουμε λίγο τον αλγόριθμο του Deutsch, αρχικά θα πρέπει να θυμόμαστε ότι η $U_f: \vert x \rangle \vert y \rangle \rightarrow \vert x \rangle \vert y \oplus f(x) \rangle$, μπορεί να αντιμετωπιστεί ως ένας $single-qubit operator \widehat(U_{f(x)})$ του οποίου η επίδραση στο δεύτερο $qubit$ εξαρτάται από την κατάσταση του πρώτου $qubit$.
Η κατάσταση $(\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}})$ είναι μια "ιδιοκατάσταση" $(eigenstate)$ της $\widehat(U_{f(x)})$ με ιδιοτιμή την $(-1)^{f(x)}$. Κωδικοποιώντας αυτές τις ιδιοτιμές με βάση το $qubit$ ελέγχου, δηλαδή το πρώτο $qubit$ μπορούμε να προσδιορίσουμε το $f(0) \oplus f(1)$, προσδιορίζοντας τους σχετικούς συντελεστές φάσης ανάμεσα στα $\vert 0 \rangle$ και $\vert 1 \rangle$. Η διάκριση μεταξύ των $(\frac{\vert 0 \rangle + \vert 1 \rangle}{\sqrt{2}})$ και $(\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}})$ γίνεται με την πύλη $Hadamard$~\cite{Kaye:2007:IQC:1206629}.

Κάτι άλλο που θα πρέπει να τονίσουμε είναι η δράση της πύλης $CNOT$. Όταν ο καταχωρητής αποτελείται από δυο $qubits$ οπως στην περίπτωση του αλγόριθμου του $Deutsch$, τότε η $CNOT$, δεν επηρεάζει την κατάσταση του πρώτου $qubit$, αλλα επιδρά στην κατάσταση του δεύτερου \textbf(εάν) το πρώτο βρίσκεται στην κατάσταση $\vert 1 \rangle$~\cite{Nakahara:2008}.

Συνοψίζοντας ο αλγόριθμος του $Deutsch$ μας δίνει λύση στο εξής:

\begin{tcolorbox}{\selectlanguage{english}The Deutsch Problem\\}
  \textbf{\selectlanguage{english}Input:} \selectlanguage{greek}Ένα μαύρο κουτί ($black box$) για τον υπολογισμό της άγνωστης συνάρτησης $f: {0,1} \rightarrow {0,1}$\\
  \textbf{\selectlanguage{english}Problem:} \selectlanguage{greek}Προσδιόρισε την τιμή της $f(0) \oplus f(1)$ κάνοντας ερωτήματα ($queries$) στην $f$
\end{tcolorbox}


% Επομένως στο πρώτο στάδιο του αλγορίθμου, ο κβανικτός καταχωρητής βρίσκεται στην κατάσταση ας την ονομάσουμε $q_1$.

% \begin{align*}
%   \vert q_1 \rangle = \vert 01 \rangle = \begin{bmatrix}
%     0 \\
%     1\\
%     0\\
%     0\\
% \end{bmatrix}
% \end{align*}
%
%
% Αμέσως μετά και πριν εφαρμοστεί η $U_f$, επιδρούν οι δύο κβαντικές πύλες $H$ και το τανυστικό γινόμενο καθώς και η νέα κατάσταση του καταχωρητή είναι:
%
% \begin{flalign*}
%   \vert q_2 \rangle = (H \oplus H) \vert q_1 \rangle &= (H \oplus H) \vert 01 \rangle =&&\\
%   &= \begin{bmatrix}
%     \frac{1}{2} &\frac{1}{2}  &\frac{1}{2}  &\frac{1}{2}\\
%     \frac{1}{2} &-\frac{1}{2} &\frac{1}{2}  &-\frac{1}{2}\\
%     \frac{1}{2} &\frac{1}{2}  &-\frac{1}{2} &-\frac{1}{2}\\
%     \frac{1}{2} &-\frac{1}{2} &-\frac{1}{2} &\frac{1}{2}\\
% \end{bmatrix}
% \begin{bmatrix}
%   0\\
%   1\\
%   0\\
%   0\\
% \end{bmatrix}=
% \begin{bmatrix}
%   \frac{1}{2}\\
%   -\frac{1}{2}\\
%   \frac{1}{2}\\
%   -\frac{1}{2}\\
% \end{bmatrix}=&&\\
% &= \frac{1}{2}\vert 00 \rangle - \frac{1}{2}\vert 10 \rangle + \frac{1}{2} \vert 10 \rangle - \frac{1}{2} \vert 11 \rangle=&&\\
% &=\frac{1}{2}(\vert 00 \rangle - \vert 01 \rangle + \vert 10 \rangle - \vert 11 \rangle)
% \end{flalign*}

\section{\tl{Deutsch-Jozsa Algorithm}}

Ο αλγόριθμος που θα δούμε τώρα αποτελεί τη λύση σε ένα πρόβλημα που είναι γενίκευση του προβλήματος που είδαμε στον αλγόριθμο του $Deutsch$. Ο αλγόριθμος έχει ακριβώς την ίδια δομή και δέχεται μια άγνωστη συνάρτηση $f$ που αυτή τη φορά είναι της μορφής:

\begin{align}
  f: {0,1}^n \rightarrow {0,1}
\end{align}

Επίσης η $f$, μπορεί να είναι είτε $constant$ (σταθερή για κάθε $x$) είτε $balanced$ (ισορροπημένη $f(x) = 0$ για τα μισά ακριβώς $x$, $f(x) = 1$ για τα υπόλοιπα $x$). Το ζητούμενο εδώ είναι να αποφασίσουμε αν τι είναι η $f$.

Ακολουθώντας την ίδια λογική που ακολουθήσαμε και στον προηγούμενο αλγόριθμο, θα ορίσουμε την κβαντική διαδικασία ως εξής:

\begin{align*}
  U_f: \vert x \rangle \vert y \rangle \rightarrow \vert x \rangle \vert y \otimes f(x) \rangle
\end{align*}

Το κύκλωμα φαίνεται παρακάτω:

\includegraphics[width=10cm]{figures/DeutschJosza}

Σε σχέση με τον αλγόριθμο του $Deutsch$, εδώ αντί για μια απλή $1-qubit$ πύλη $Hadamard$, έχουμε $n 1-qubit$ πύληες $Hadamard$ και συμβολίζεται $H^{\oplus n}$. Χρησιμοποιούμε το συμβολισμό $\vert 0 \rangle^{\otimes n}$ ή $\vert \textbf{0} \rangle$ για την κατάσταση που είναι $tensor product$ από $n qubits$ το καθένα στην κατάσταση $\vert 0 \rangle$.

Ακολουθούμε λοιπόν την πορεία του κυκλώματατος.
Αρχική κατάσταση

\begin{align}
  \vert \psi_0 \rangle = \vert 0 \rangle^{\oplus n}(\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}})
\end{align}

Υπολογίζοντας τη δράση ενός $n-qubit Hadamard$ μετασχηματισμού στην κατάσταση $\vert 0 \rangle^{\oplus n}$

\begin{align}
  H^{\oplus n} \vert 0 \rangle^{\oplus 0} = (\frac{1}{\sqrt{2}})^n \underbrace{(\vert 0 \rangle + \vert 1 \rangle) \otimes (\vert 0 \rangle + \vert 1 \rangle) \otimes ... \otimes(\vert 0 \rangle + \vert 1 \rangle)}_{n}
\end{align}

Και εξάγοντας το $tensor product$ μπορεί να γραφτεί σαν

\begin{align}
  H^{\otimes n} \vert 0 \rangle^{\otimes n} = \frac{1}{\sqrt{2^n}} \sum_{x \epsilon {0,1}^n} \vert x \rangle
\end{align}

Αμέσως μετά την πρώτη $H^{\otimes n}$ ο αλγόριθμος είναι

\begin{align}
  \vert \psi_1 \rangle = \frac{1}{\sqrt{2^n}} \sum_{x \epsilon {0,1}^n} \vert n \rangle \frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}}
\end{align}

Η εγγραφή στον καταχωρητή είναι σε μια ισόβαρη υπέρθεση όλων των πιθανών $n-bit string$ εισόδου. Τώρα δρα η $U_f$

\begin{flalign}
  \vert \psi_2 \rangle &= \frac{1}{\sqrt{2^n}}U_f(\sum_{x \epsilon {0,1}^n}\vert x \rangle (\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}})) =&&\\
&= \frac{1}{\sqrt{2^n}} \sum_{x \epsilon {0,1}^n} (-1)^{f(x)} \vert x \rangle (\frac{\vert 0 \rangle - \vert 1 \rangle}{\sqrt{2}})
\end{flalign}



\section{\tl{Simon's Algorithm}}

\section{\tl{Grover's Algorithm}}

\section{\tl{Quantum Search Algorithms}}
